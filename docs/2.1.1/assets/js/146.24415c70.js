(window.webpackJsonp=window.webpackJsonp||[]).push([[146],{193:function(e,t,a){"use strict";a.r(t);var n=a(1),r=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[e._m(0),e._v(" "),a("Seo"),e._v(" "),a("p",[e._v("SiteWhere has been designed from the ground up to take advantage of the latest\ntechnologies in order to scale efficiently to the loads expected in large IoT\nprojects. Rather than using a monolithic architecture, SiteWhere embraces\na completely distributed architecture using "),a("a",{attrs:{href:"https://kubernetes.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Kubernetes"),a("OutboundLink")],1),e._v("\nas the infrastructure and a variety of microservices to build out the system.\nThis approach allows customization and scaling at a fine-grained level\nso that the system may be tailored to many potential IoT use cases. SiteWhere\nis built with a framework approach using clearly defined APIs so that new\ntechnologies may easily be integrated as the IoT ecosystem evolves.")]),e._v(" "),e._m(1),e._v(" "),a("p",[e._v("Rather than using a monolithic approach, SiteWhere is based on many microservices\nrunning as a distributed system. Each microservice is a completely self-contained\nentity that has its own configuration schema, internal components, data persistence,\nand interactions with the event processing pipeline. SiteWhere microservices\nare built on top of a custom microservice framework and run as separate\n"),a("a",{attrs:{href:"https://projects.spring.io/spring-boot/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Spring Boot"),a("OutboundLink")],1),e._v(" processes, each\ncontained in its own "),a("a",{attrs:{href:"https://www.docker.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker"),a("OutboundLink")],1),e._v(" image.")]),e._v(" "),e._m(2),e._v(" "),a("p",[e._v("Separating the system logic into microservices allows the interactions\nbetween various areas of the system to be more clearly defined. Each microservice\nserves a singular functional purpose and handles all aspects of that\nfunctionality. Other microservices which need to access the functionality\ncontained in external services do so via clearly defined APIs.")]),e._v(" "),e._m(3),e._v(" "),a("p",[e._v("The microservice architecture allows individual functional areas of the system to be scaled\nindependently or left out completely. In use cases where REST processing tends to\nbe a bottleneck, multiple REST microservices can be run concurrently to handle the load.\nConversely, services such as presence management that may not be required can be left\nout so that processing power can be dedicated to other aspects of the system.")]),e._v(" "),e._m(4),e._v(" "),a("p",[e._v("SiteWhere relies on Kubernetes for service orchestration, leveraging the\nwealth of existing infrastructure and proven methodologies it provides.\nThis allows SiteWhere to run on almost all existing cloud platforms as\nwell as on-premise installations. To simplify installation and configuration,\n"),a("a",{attrs:{href:"https://helm.sh/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Helm"),a("OutboundLink")],1),e._v(" is used to provide standard templates for various\ndeployment scenarios. Helm "),a("a",{attrs:{href:"https://github.com/sitewhere/sitewhere-recipes/tree/master/charts",target:"_blank",rel:"noopener noreferrer"}},[e._v("charts"),a("OutboundLink")],1),e._v("\nare provided to supply both the microservices and the dependencies needed to\nrun a complete SiteWhere deployment. Infrastructure components include\ntechnologies such as Apache Zookeeper and Kafka, highly available databases such\nas MongoDB, InfluxDB, and Cassandra, and other supporting technologies\nsuch as MQTT brokers.")]),e._v(" "),e._m(5),e._v(" "),e._m(6),e._v(" "),a("p",[e._v("Rather than reinventing the wheel, SiteWhere uses a number of proven technologies\nas part of the infrastructure for its microservice architecture. The following\ntechnologies address cross-cutting concerns which are common to all of the\nsystem microservices.")]),e._v(" "),e._m(7),e._v(" "),a("p",[e._v("SiteWhere leverages "),a("a",{attrs:{href:"https://istio.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Istio"),a("OutboundLink")],1),e._v(" to provide a service mesh for\nthe system microservices. This allows the platform to be scaled dynamically while\nalso providing a great deal of control over how data is routed. Istio allows\nmodern methods such as canary testing and fault injection to be used to\nprovide a more robust and fault-tolerant system. It also allows for detailed\nmonitoring and tracing of the data flowing between microservices.")]),e._v(" "),e._m(8),e._v(" "),a("p",[e._v("SiteWhere configuration is stored in "),a("a",{attrs:{href:"https://zookeeper.apache.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Apache ZooKeeper"),a("OutboundLink")],1),e._v("\nto allow for a scalable, externalized approach to configuration management. ZooKeeper\ncontains a hierarchical structure which represents the configuration for one or more\nSiteWhere instances and all of the microservices that are used to realize them. The\nconfiguration is replicated for high availabilty.")]),e._v(" "),a("p",[e._v("Each microservice has a direct connection to ZooKeeper and uses the hierarchy to\ndetermine its configuration at runtime. Microservices listen for changes to the\nconfiguration data and react dynamically to updates. No configuration\nis stored locally within the microservice, which prevents problems with\nkeeping services in sync as system configuration is updated.")]),e._v(" "),e._m(9),e._v(" "),a("p",[e._v("Many system components such as Zookeeper, Kafka, and various\ndatabases require access to persistent storage which is available to all\nnodes in the Kubernetes cluster. This provides resilience in cases where\na Kubernetes node fails and pods are scheduled on other nodes to restore\nthe system to a running state. SiteWhere uses "),a("a",{attrs:{href:"https://rook.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Rook.io"),a("OutboundLink")],1),e._v("\nto provide a consistent approach to scalable storage. Rook supplies distributed,\nreplicated block storage that is resilient to hardware failures while\nstill offering good performance characteristics. As storage and throughput\nneeds increase over time, new storage devices can be made available\ndynamically. The underlying "),a("a",{attrs:{href:"https://ceph.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Ceph"),a("OutboundLink")],1),e._v(" architecture\nused by Rook.io can handle "),a("em",[e._v("exobytes")]),e._v(" of data while allowing data\nto be resilient to failures at the node, rack, or even datacenter level.")]),e._v(" "),e._m(10),e._v(" "),a("p",[e._v("SiteWhere coordinates device event processing by arranging microservices into\na pipeline with each microservice managing a specific stage of the process.\nThis approach allows events to be processed incrementally while also allowing\nthe processing load to be spread across hardware and scaled at a more fine-grained level.")]),e._v(" "),a("p",[e._v("The event processing pipeline uses "),a("a",{attrs:{href:"https://kafka.apache.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Apache Kafka"),a("OutboundLink")],1),e._v("\nto provide a resilient, high-performance mechanism for moving device event data\nbetween the microservices that make up the pipeline. Microservices plug in\nat key points in the event processing pipeline, reading data from well-known inbound\ntopics, processing data, then sending data to well-known outbound topics.\nExternal entites that are interested in data at any point in the pipeline\ncan act as consumers of the SiteWhere topics to consume the data as it moves\nthrough the system.")]),e._v(" "),e._m(11),e._v(" "),a("p",[e._v("The SiteWhere event processing pipeline leverages Kafka's messaging constructs to allow\ndevice event data to be processed asynchronously. If a microservice shuts down and no other\nreplicas are available to process the load, the data will be queued until a replica starts\nand begins processing again. This acts as a guarantee against data loss as data is always\nbacked by Kafka's high-performance storage. SiteWhere microservices leverage Kafka's consumer\ngroups concept to distribute load across multiple consumers and scale processing accordingly.")]),e._v(" "),a("p",[e._v('Using Kafka also has other advantages that are leveraged by SiteWhere. Since all data in\nthe distributed log is stored on disk, it is possible to "replay" the event stream based\non previously gathered data. This is extremely valuable for aspects such as debugging\nprocessing logic or load testing the system.')]),e._v(" "),e._m(12),e._v(" "),a("p",[e._v("While device event data generally flows in a pipeline from microservice to microservice on\nKafka topics, there are also API operations that need to occur in real time between the\nmicroservices. For instance, device management and event management functions are contained in\ntheir own microservices, but are required by many other components of the system. Many of the\nSiteWhere microservices offer APIs which may be accessed by other microservices to\nsupport aspects such as storing persistent data or initiating microservice-specific\nservices.")]),e._v(" "),e._m(13),e._v(" "),a("p",[e._v("Rather than using REST services based on HTTP 1.x, which tend to have significant\nconnection overhead, SiteWhere uses "),a("a",{attrs:{href:"https://grpc.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("gRPC"),a("OutboundLink")],1),e._v(" to establish a long-lived\nconnection between microservices that need to communicate with each other. Since gRPC uses\npersistent HTTP2 connections, the overhead for interactions is greatly reduced, allowing\nfor decoupling without a significant performance penalty. Istio also allows the gRPC\nconnections to be multiplexed across multiple replicas of a microservice to scale\nprocessing and offer redundancy.")]),e._v(" "),a("p",[e._v("The entire SiteWhere data model has been captured in\n"),a("a",{attrs:{href:"https://developers.google.com/protocol-buffers/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Google Protocol Buffers"),a("OutboundLink")],1),e._v(" format so that\nit can be used within GRPC services. All of the SiteWhere APIs are exposed directly as\ngRPC services as well, allowing for high-performance, low-latency access to all API\nfunctions. The REST APIs are still made available via the Web/REST microservice (acting\nas an API gateway), but they use the gRPC APIs underneath to provide a consistent approach\nto accessing data.")]),e._v(" "),e._m(14),e._v(" "),a("p",[e._v("SiteWhere is designed for large-scale IoT projects which may involve many system tenants\nsharing a single SiteWhere instance. A key differentiator for SiteWhere compared to most\nIoT platforms is that each tenant runs in isolation from other tenants. By default, tenants\ndo not share database resources or pipeline processing and have a completely separate\nconfiguration lifecycles. With this approach, each tenant may use its own database\ntechnologies, external integrations, and other configuration options. Parts of the tenant's\nprocessing pipeline may be reconfigured/restarted without causing an interruption to\nother tenants.")]),e._v(" "),e._m(15),e._v(" "),a("p",[e._v("An important consequence of the way SiteWhere handles multitenancy is that each tenant's\ndata is separated from the data of other tenants. Most platforms that offer multitenancy\nstore data for all tenants in shared tables, differentiated only by a tenant id. The shared\napproach opens up the possibility of one tenant's data corrupting another, which is not\nan acceptable risk in many IoT deployments. In addition, each tenant has its own processing\npipelines, so in-flight data is never co-mingled.")]),e._v(" "),e._m(16)],1)}),[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"system-architecture"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#system-architecture","aria-hidden":"true"}},[this._v("#")]),this._v(" System Architecture")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"microservice-approach"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#microservice-approach","aria-hidden":"true"}},[this._v("#")]),this._v(" Microservice Approach")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"separation-of-concerns"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#separation-of-concerns","aria-hidden":"true"}},[this._v("#")]),this._v(" Separation of Concerns")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"scale-what-you-need-leave-out-what-you-don-t"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#scale-what-you-need-leave-out-what-you-don-t","aria-hidden":"true"}},[this._v("#")]),this._v(" Scale What You Need. Leave Out What You Don't")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"kubernetes-orchestration"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes-orchestration","aria-hidden":"true"}},[this._v("#")]),this._v(" Kubernetes Orchestration")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"core-technologies"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#core-technologies","aria-hidden":"true"}},[this._v("#")]),this._v(" Core Technologies")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("When deploying SiteWhere, the combination of the infrastructure required to\nrun the system and the microservices that handle the processing are referred\nto as a SiteWhere "),t("em",[this._v("instance")]),this._v(". The assumption is that all infrastructure and\nmicroservices for an instance run on the same Kubernetes cluster, though the\nsystem may be spread across tens or hundreds of machines to distribute the processing\nload.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"service-mesh-with-istio"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#service-mesh-with-istio","aria-hidden":"true"}},[this._v("#")]),this._v(" Service Mesh with Istio")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"centralized-configuration-management-with-apache-zookeeper"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#centralized-configuration-management-with-apache-zookeeper","aria-hidden":"true"}},[this._v("#")]),this._v(" Centralized Configuration Management with Apache ZooKeeper")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"distributed-storage-with-rook-io"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#distributed-storage-with-rook-io","aria-hidden":"true"}},[this._v("#")]),this._v(" Distributed Storage with Rook.io")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"event-data-processing-pipeline"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#event-data-processing-pipeline","aria-hidden":"true"}},[this._v("#")]),this._v(" Event Data Processing Pipeline")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"fully-asynchronous-pipeline-processing"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fully-asynchronous-pipeline-processing","aria-hidden":"true"}},[this._v("#")]),this._v(" Fully Asynchronous Pipeline Processing")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"api-connectivity-between-microservices"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#api-connectivity-between-microservices","aria-hidden":"true"}},[this._v("#")]),this._v(" API Connectivity Between Microservices")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"using-grpc-for-a-performance-boost"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#using-grpc-for-a-performance-boost","aria-hidden":"true"}},[this._v("#")]),this._v(" Using gRPC for a Performance Boost")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"multitenancy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#multitenancy","aria-hidden":"true"}},[this._v("#")]),this._v(" Multitenancy")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"data-privacy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#data-privacy","aria-hidden":"true"}},[this._v("#")]),this._v(" Data Privacy")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Having dedicated resources for tenants can be expensive in terms of memory and processing\nresources, so SiteWhere also offers the concept of "),t("em",[this._v("customers")]),this._v(" within each tenant. Customers\nallow data to be differentiated within a tenant, but without having a separate dedicated\ndatabase and pipelines. In cases where colocated data is acceptable, the tenant can have\nany number of customers, which share the same database and processing pipeline. This allows\nthe best of both worlds in terms of security and scalability.")])}],!1,null,null,null);r.options.__file="architecture.md";t.default=r.exports}}]);