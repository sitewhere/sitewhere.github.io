(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{182:function(e,a,o){"use strict";o.r(a);var s=o(1),n=Object(s.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,a=e.$createElement,o=e._self._c||a;return o("div",{staticClass:"content"},[o("h1",{attrs:{id:"arquitectura-de-sitewhere"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#arquitectura-de-sitewhere","aria-hidden":"true"}},[e._v("#")]),e._v(" Arquitectura de SiteWhere")]),e._v(" "),o("p",[e._v("SiteWhere ha sido diseñado desde cero para aprovechar las últimas novedades\ntecnologías para escalar de manera eficiente a las cargas esperadas en IoT grande\nproyectos. En lugar de utilizar una arquitectura monolítica, SiteWhere abraza\nun enfoque completamente distribuido utilizando microservicios para permitir escalar en el\nnivel de componente para que el sistema se pueda adaptar al cliente\ncaso de uso El sistema se construye con un enfoque de marco usando claramente definido\nAPI para que las nuevas tecnologías puedan integrarse fácilmente como ecosistema de IoT\nevoluciona El resto de esta guía cubre las tecnologías centrales utilizadas por\nSiteWhere y cómo encajan para construir un sistema integral.")]),e._v(" "),o("h2",{attrs:{id:"microservicios"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#microservicios","aria-hidden":"true"}},[e._v("#")]),e._v(" Microservicios")]),e._v(" "),o("p",[e._v("SiteWhere 2.0 presenta un enfoque arquitectónico muy diferente del que se utilizó\nen la plataforma 1.x Si bien las API principales no se modifican en su mayoría, la implementación del sistema\nha pasado de un enfoque monolítico a uno basado en microservicios. Este enfoque\nproporciona una serie de ventajas sobre la arquitectura anterior.")]),e._v(" "),o("h3",{attrs:{id:"separacion-de-intereses"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#separacion-de-intereses","aria-hidden":"true"}},[e._v("#")]),e._v(" Separación de intereses")]),e._v(" "),o("p",[e._v("Cada microservicio es una entidad completamente autónoma que tiene su\npropio esquema de configuración único, componentes internos, persistencia de datos,\ne interacciones con el canal de procesamiento de eventos. SiteWhere microservicios\nse construyen sobre una estructura de microservicio personalizada y se ejecutan por separado\n[Spring Boot] (https://projects.spring.io/spring-boot/) procesos, cada uno\ncontenido en su propia imagen [Docker] (https://www.docker.com/).")]),e._v(" "),o("p",[e._v("Separar la lógica del sistema en microservicios permite las interacciones\nentre varias áreas del sistema para ser definido más claramente. Esta\ntransición ya ha resultado en una más comprensible y sostenible\nsistema y debería seguir pagando dividendos a medida que se agregan más características.")]),e._v(" "),o("h3",{attrs:{id:"escala-lo-que-necesitas-deje-fuera-lo-que-no-hace"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#escala-lo-que-necesitas-deje-fuera-lo-que-no-hace","aria-hidden":"true"}},[e._v("#")]),e._v(" Escala lo que necesitas. Deje fuera lo que no hace")]),e._v(" "),o("p",[e._v("La arquitectura de microservicio permite escalar las áreas funcionales individuales del sistema\nindependientemente o se omite por completo. En casos de uso donde el procesamiento REST tiende a\nser un cuello de botella, múltiples microservicios REST se pueden ejecutar simultáneamente para manejar la carga.\nPor el contrario, los servicios tales como la gestión de presencia que pueden no ser necesarios se pueden dejar\nde modo que la potencia de procesamiento se pueda dedicar a otros aspectos del sistema.")]),e._v(" "),o("h2",{attrs:{id:"instance-management"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#instance-management","aria-hidden":"true"}},[e._v("#")]),e._v(" Instance Management")]),e._v(" "),o("p",[e._v("La arquitectura 2.0 introduce el concepto de SiteWhere "),o("em",[e._v("instance")]),e._v(", que\npermite que el sistema distribuido actúe como una unidad cohesiva con algunos aspectos\ndirigido a nivel global. Todos los microservicios para un único sitio donde\nla instancia debe ejecutarse en la misma infraestructura Docker, aunque el sistema\npuede distribuirse en decenas o cientos de máquinas usando tecnologías tales como\n[Docker Swarm] (https://github.com/docker/swarm) o [Kubernetes] (https://kubernetes.io/).")]),e._v(" "),o("h2",{attrs:{id:"configuration-management-con-apache-zookeeper"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#configuration-management-con-apache-zookeeper","aria-hidden":"true"}},[e._v("#")]),e._v(" Configuration Management con Apache ZooKeeper")]),e._v(" "),o("p",[e._v("SiteWhere 2.0 mueve la configuración del sistema desde el sistema de archivos a\n[Apache ZooKeeper] (https://zookeeper.apache.org/) para permitir una centralización\nenfoque a la gestión de la configuración. ZooKeeper contiene una estructura jerárquica\nque representa la configuración para una o más instancias de SiteWhere\ny todos los microservicios que se usan para realizarlos.")]),e._v(" "),o("p",[e._v("Cada microservicio tiene una conexión directa con ZooKeeper y usa el\njerarquía para determinar su configuración en tiempo de ejecución. Los microservicios escuchan los cambios\na los datos de configuración y reaccionan dinámicamente a las actualizaciones. Sin configuración\nse almacena localmente dentro del microservicio, lo que evita problemas con\nmantener los servicios sincronizados a medida que se actualiza la configuración del sistema.")]),e._v(" "),o("h2",{attrs:{id:"procesamiento-de-eventos-con-apache-kafka"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#procesamiento-de-eventos-con-apache-kafka","aria-hidden":"true"}},[e._v("#")]),e._v(" Procesamiento de eventos con Apache Kafka")]),e._v(" "),o("p",[e._v("El canal de procesamiento de eventos en SiteWhere 2.0 ha sido completamente rediseñado y utiliza\n[Apache Kafka] (https://kafka.apache.org/) para proporcionar un rendimiento resistente y de alto rendimiento\nmecanismo para procesar progresivamente datos de eventos del dispositivo. Cada microservicio se conecta a\npuntos clave en el proceso de procesamiento de eventos, leyendo datos de temas entrantes conocidos,\nprocesar datos y luego enviar datos a temas salientes conocidos. Entidades externas que\nestán interesados ​​en los datos en cualquier punto de la tubería pueden actuar como consumidores del Sitio donde\ntemas para usar los datos mientras se mueve a través del sistema.")]),e._v(" "),o("p",[e._v("En la arquitectura SiteWhere 1.x, la canalización para el proceso de salida utilizó un bloqueo\nenfoque que significaba que cualquier procesador de salida solo podría bloquear la tubería de salida.\nEn SiteWhere 2.0, cada conector de salida es un verdadero consumidor de Kafka con su propia compensación\nmarcador en la secuencia del evento. Este mecanismo permite que los procesadores de salida procesen datos\na su propio ritmo sin ralentizar a otros procesadores.")]),e._v(" "),o("p",[e._v('Usar Kafka también tiene otras ventajas aprovechadas por SiteWhere. Dado que todos los datos para\nel registro distribuido se almacena en el disco, es posible "reproducir" el flujo de eventos\nen datos recolectados previamente. Esto es extremadamente valioso para aspectos como la depuración\nlógica de procesamiento o prueba de carga del sistema.')]),e._v(" "),o("h2",{attrs:{id:"comunicacion-entre-microservicios-con-grpc"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#comunicacion-entre-microservicios-con-grpc","aria-hidden":"true"}},[e._v("#")]),e._v(" Comunicación entre microservicios con GRPC")]),e._v(" "),o("p",[e._v("Mientras que los datos de evento del dispositivo generalmente fluyen en una tubería desde microservicio a microservidor")])])}],!1,null,null,null);n.options.__file="architecture.md";a.default=n.exports}}]);