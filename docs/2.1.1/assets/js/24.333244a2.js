(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{180:function(e,a,i){"use strict";i.r(a);var s=i(1),n=Object(s.a)({},(function(){var e=this,a=e.$createElement,i=e._self._c||a;return i("div",{staticClass:"content"},[e._m(0),e._v(" "),i("p",[e._v("La transición de una arquitectura monilítica a una basada en microservicios es\nuna característica clave de la arquitectura de SiteWhere 2.0. Cada microservicio\nmaneja un subconjunto específico de funcionalidades que están claramente definidas\ny delineadas del trabajo realizado por otros microservicios. Esto permite que las partes\ndel sistema se escalen de forma independiente, a la vez que permite que algunas piezas\nse excluyan por completo si no se utilizan. El enfoque de microservicios también desacopla\nel código para que sea más fácil de entender y gestionar desde una perspectiva de desarrollo.\nEl siguiente diagrama muestra los microservicios y el flujo general de datos entre ellos:")]),e._v(" "),i("InlineImage",{attrs:{src:"/images/platform/microservices-diagram.png",caption:"Microservices"}}),e._v(" "),e._m(1),e._v(" "),i("p",[e._v("Los microservicios de SiteWhere hacen algunas suposiciones sobre la infraestructura\nsubyacente en la que se están ejecutando. Como mínimo, las instancias de Apache\nZooKeeper y Apache Kafka deben estar disponibles para que el sistema funcione\ncorrectamente. De forma predeterminada, SiteWhere también produce datos de\nseguimiento distribuidos a través del estándar "),i("a",{attrs:{href:"http://opentracing.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("open tracing"),i("OutboundLink")],1),e._v("\npara el análisis del rendimiento en tiempo de ejecución. Un servidor de backend que\nadmita la API se puede configurar para almacenar y analizar los datos.")]),e._v(" "),e._m(2),e._v(" "),i("p",[e._v("Al iniciar desde Docker Compose o Swarm, hay "),i("a",{attrs:{href:"https://github.com/sitewhere/sitewhere-recipes",target:"_blank",rel:"noopener noreferrer"}},[e._v("recetas"),i("OutboundLink")],1),e._v("\ndisponibles que se pueden usar para proporcionar los componentes de infraestructura\nesperados. Las recetas incluyen los componentes necesarios, como ZooKeeper y Kafka,\nasí como otros componentes de soporte, como "),i("a",{attrs:{href:"https://github.com/jaegertracing/jaeger",target:"_blank",rel:"noopener noreferrer"}},[e._v("Jaeger"),i("OutboundLink")],1),e._v("\npara el seguimiento de soporte y "),i("a",{attrs:{href:"https://github.com/elkozmon/zoonavigator",target:"_blank",rel:"noopener noreferrer"}},[e._v("ZooNavigator"),i("OutboundLink")],1),e._v("\npara introspección de la tienda ZooKeeper.")]),e._v(" "),e._m(3),e._v(" "),i("p",[e._v("En un escenario de producción, ZooKeeper y Kafka deben configurarse fuera de\nDocker y deben escalarse adecuadamente para tener en cuenta la tolerancia a fallas\ny la disponibilidad. El equipo de SiteWhere ofrecerá más detalles sobre las\nmejores prácticas a medida que nos acercamos a la versión 2.0 GA.")]),e._v(" "),e._m(4),e._v(" "),i("p",[e._v("Cada microservicio se empaqueta como una aplicación Spring Boot y se implementa\ncomo una imagen Docker independiente. Como cada microservicio se ejecuta en un\ncontenedor Docker independiente, cada uno representa un proceso de Java separado\nen lugar de todos los servicios que se ejecutan dentro del mismo proceso en 1.x.")]),e._v(" "),e._m(5),e._v(" "),i("p",[e._v("SiteWhere 2.0 utiliza actualmente alrededor de 20 microservicios, por lo que el\nhardware subyacente debería ser capaz de admitir la ejecución de 20 procesos\nsimultáneos de Java, cada uno con una huella de alrededor de 750 MB. Como tal,\nlos requisitos de hardware para 2.0 son más altos que 1.x, aunque la mayoría de\nlas computadoras de escritorio modernas pueden ejecutar fácilmente un sistema completo.\nLa intención de SiteWhere 2.0 es utilizar motores de orquestación como Docker\nSwarm para distribuir los microservicios a través de un conjunto de máquinas,\nlo que reduce los requisitos de hardware para un solo nodo. Al final, aunque\nSiteWhere 2.0 tiene una huella más grande, la arquitectura admite muchos más\nsistemas escalables que pueden aprovechar grandes grupos de hardware y escalar\ndinámicamente....")]),e._v(" "),e._m(6),e._v(" "),i("p",[e._v("Los microservicios no funcionan en el vacío y, como tal, se necesita un mecanismo de RPC\n(Llamada a Procedimientos Remotos) de alto rendimiento para permitir que los servicios\nse comuniquen. SiteWhere aprovecha "),i("a",{attrs:{href:"https://grpc.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("gRPC"),i("OutboundLink")],1),e._v(" para mover datos entre\nmicroservicios y ofrecer API binarias de rendimiento a los consumidores externos.\nTodas las llamadas de API y las entidades de datos se han puesto a disposición\nde gRPC a través del formato de datos de los Protocol Buffers de Google.\nUsar gRPC en lugar de REST para la comunicación puede aumentar el rendimiento\nde la API en más de 10x.")]),e._v(" "),e._m(7),e._v(" "),i("p",[e._v("Las conexiones entre microservicios no son siempre uno a uno. Por ejemplo, si una instancia\nde SiteWhere tiene un solo servicio Web/REST y tres instancias del microservicio Device Management,\nel servicio de REST debe poder desmultiplexar las llamadas entre las tres instancias de\nDevice Management para escalabilidad y tolerancia a fallas. SiteWhere 2.0 presenta el\nconcepto de un demulitplexor de API que puede introspectar la topología de instancia actual\ny agregar/eliminar conexiones dinámicamente a otros microservicios. A medida que la\ncantidad de servicios aumenta/reduce de escala SiteWhere se conecta/desconecta automáticamente\nla tubería entre ellos. Toda la comunicación entre microservicios ocurre a través de este mecanismo.")]),e._v(" "),e._m(8),e._v(" "),i("p",[e._v("Incluso con el alto rendimiento de gRPC, solicitar datos comúnmente usados repetidamente\na través de la conexión de red tiene un costo significativo. La información maestra para\nentidades tales como dispositivos, asignaciones y activos rara vez se actualiza y puede\nalmacenarse en caché dentro de una cuadrícula de datos en memoria en lugar de incurrir\nen el costo de lectura de la base de datos. SiteWhere 2.0 utiliza una grid en memoria\nHazelcast para proporcionar un caché distribuido de un subconjunto de datos maestros.\nEsta caché se consulta antes de volver a caer en una solicitud de base de datos.")]),e._v(" "),e._m(9),e._v(" "),i("p",[e._v("A continuación se muestra una lista de los microservicios principales incluidos\nen SiteWhere 2.0. Cada servicio maneja un área específica de la funcionalidad\ndel sistema y es independiente de otros microservicios en términos de procesamiento\nde tiempo de ejecución, almacenamiento y configuración de datos. Sin embargo,\nalgunos microservicios tienen dependencias en las API que ofrecen otros servicios\ny no pueden ejecutarse de forma aislada. A continuación hay una descripción\ngeneral de alto nivel de los servicios individuales junto con enlaces a explicaciones\nmás detalladas de cada servicio.")]),e._v(" "),e._m(10),e._v(" "),e._m(11),e._v(" "),i("p",[e._v("Consulte la "),i("router-link",{attrs:{to:"./../guide/microservices/instance-management.html"}},[e._v("guía")]),e._v(" de gestión de instancias\npara más detalles.")],1),e._v(" "),e._m(12),e._v(" "),e._m(13),e._v(" "),e._m(14),e._v(" "),e._m(15),e._v(" "),e._m(16),e._v(" "),e._m(17),e._v(" "),i("p",[e._v("El microservicio Web/REST global incluye un contenedor Tomcat que proporciona infraestructura\npara todos los servicios REST básicos (incluidas las interfaces de usuario de Swagger).\nEste microservicio generalmente está conectado a todos los demás microservicios en el\nsistema, de modo que las llamadas API pueden delegarse a los microservicios que implementan\nla funcionalidad. Por ejemplo, consultar un dispositivo a través de las API REST da como\nresultado una solicitud gRPC (potencialmente almacenada en caché a través de Hazelcast)\nen el motor de inquilino de gestión de dispositivos apropiado en uno de los microservicios de\ngestión de dispositivos.")]),e._v(" "),e._m(18),e._v(" "),e._m(19),e._v(" "),e._m(20),e._v(" "),e._m(21),e._v(" "),e._m(22),e._v(" "),e._m(23),e._v(" "),e._m(24),e._v(" "),e._m(25),e._v(" "),e._m(26),e._v(" "),e._m(27),e._v(" "),e._m(28),e._v(" "),i("p",[e._v("Cada motor de tenant de operaciones por lotes también contiene un administrador de operaciones por\nlotes que puede configurarse para procesar las operaciones por lotes que se crean a través de las API.\nEl administrador de operaciones por lotes convertirá la solicitud del lote en muchas operaciones más\npequeñas para lograr el objetivo del lote.")]),e._v(" "),e._m(29),e._v(" "),e._m(30),e._v(" "),e._m(31),e._v(" "),e._m(32),e._v(" "),e._m(33),e._v(" "),i("p",[e._v("Una vez que el evento entrante se ha enriquecido, se reenvía al microservicio de gestión de eventos\npara su persistencia. El evento persistente se devuelve (asincrónicamente) eventualmente al procesamiento\nentrante donde se agrega a un topic para eventos preprocesados ​​que a su vez pueden ser consumidos por otros\nmicroservicios, tales como el procesamiento de reglas y los conectores salientes.")]),e._v(" "),e._m(34),e._v(" "),e._m(35),e._v(" "),i("p",[e._v('Los eventos que no dan como resultado el registro automático de un dispositivo son llevados a\nun topic de "letra muerta" en Kafka para que los procesadores externos puedan rastrearlos\no procesarlos fuera de banda.')]),e._v(" "),e._m(36),e._v(" "),e._m(37),e._v(" "),e._m(38),e._v(" "),e._m(39),e._v(" "),e._m(40),e._v(" "),e._m(41),e._v(" "),e._m(42),e._v(" "),e._m(43),e._v(" "),e._m(44),e._v(" "),e._m(45),e._v(" "),e._m(46),e._v(" "),e._m(47),e._v(" "),e._m(48),e._v(" "),e._m(49),e._v(" "),e._m(50),e._v(" "),e._m(51),e._v(" "),e._m(52)],1)}),[function(){var e=this.$createElement,a=this._self._c||e;return a("h1",{attrs:{id:"descripcion-de-los-microservicios"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#descripcion-de-los-microservicios","aria-hidden":"true"}},[this._v("#")]),this._v(" Descripción de los Microservicios")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h2",{attrs:{id:"componentes-de-infraestructura"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#componentes-de-infraestructura","aria-hidden":"true"}},[this._v("#")]),this._v(" Componentes de Infraestructura")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"recetas-de-infraestructura"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#recetas-de-infraestructura","aria-hidden":"true"}},[this._v("#")]),this._v(" Recetas de Infraestructura")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h2",{attrs:{id:"despliegues-en-produccion"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#despliegues-en-produccion","aria-hidden":"true"}},[this._v("#")]),this._v(" Despliegues en Producción")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h2",{attrs:{id:"modelo-de-despliegue-de-microservicios"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#modelo-de-despliegue-de-microservicios","aria-hidden":"true"}},[this._v("#")]),this._v(" Modelo de Despliegue de Microservicios")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"utilizacion-de-recursos-del-systema"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#utilizacion-de-recursos-del-systema","aria-hidden":"true"}},[this._v("#")]),this._v(" Utilización de Recursos del Systema")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h2",{attrs:{id:"conectividad-inter-microservicios"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#conectividad-inter-microservicios","aria-hidden":"true"}},[this._v("#")]),this._v(" Conectividad Inter-Microservicios")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"api-demultiplexores"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#api-demultiplexores","aria-hidden":"true"}},[this._v("#")]),this._v(" API Demultiplexores")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h2",{attrs:{id:"soporte-de-cache-distribuido"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#soporte-de-cache-distribuido","aria-hidden":"true"}},[this._v("#")]),this._v(" Soporte de Cache Distribuido")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h2",{attrs:{id:"lista-de-princiaples-microservicios"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lista-de-princiaples-microservicios","aria-hidden":"true"}},[this._v("#")]),this._v(" Lista de Princiaples Microservicios")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"instance-management"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#instance-management","aria-hidden":"true"}},[this._v("#")]),this._v(" Instance Management")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de gestión de instancias ("),a("em",[this._v("instance management")]),this._v(") se utiliza para iniciar una instancia\nde SiteWhere con la estructura de configuración inicial de Zookeeper requerida\npor los otros microservicios. Todos los demás microservicios esperan a que se\ninicialicen los datos de Zookeeper antes de comenzar, por lo que el microservicio\nde gestión de instancias debe estar presente en una instancia de SiteWhere no\niniciada o todos los demás microservicios no podrán iniciarse.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"user-management"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#user-management","aria-hidden":"true"}},[this._v("#")]),this._v(" User Management")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de administración de usuarios ("),a("em",[this._v("user management")]),this._v(") global proporciona las API principales\ny la persistencia de datos utilizada para administrar usuarios del sistema.\nInicialmente es utilizado por el microservicio de gestión de instancias ("),a("em",[this._v("instance management")]),this._v(")\npara arrancar el sistema con los usuarios base. Posteriormente, el servicio Web/REST\nlo llama para permitir que se administre la lista de usuarios.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"tenant-management"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tenant-management","aria-hidden":"true"}},[this._v("#")]),this._v(" Tenant Management")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio gobal de administración de "),a("em",[this._v("tenants")]),this._v(" ("),a("em",[this._v("tenant management")]),this._v(") proporciona\nlas API centrales y la persistencia de datos para administrar a los tenants del sistema.\nInicialmente, el microservicio de gestión de instancias lo utiliza para iniciar el sistema con los\ntenants base. Posteriormente, el microservicio Web/REST lo llama para permitir que se administre\nla lista de tenants del sistema.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("Cuando se agrega/actualiza/borra un tenant, los datos del tenant se envían a un "),a("em",[this._v("topic")]),this._v(" de Kafka\npara que otros oyentes interesados ​​puedan actuar sobre la actualización. De forma predeterminada,\nun oyente se registra para impulsar a los tenants recién creados al agregar la jerarquía de\nconfiguración de tenant esperada en ZooKeeper. Este proceso incluye copiar los archivos de\nconfiguración XML por microservicio de la plantilla de tenant en ZooKeeper, y luego ejecutar\nla lista de scripts de inicialización incluidos con la plantilla. Una vez que se completa este proceso,\nla configuración del tenant se marca como boostrapped para que otros microservicios puedan reaccionar\nante el tenant adicional. Por ejemplo, el servicio de microservicio de administración de dispositivos\nnotará que se ha configurado un nuevo tenant y esperará el indicador bootstrapped, luego cargará el\nrchivo de configuración device-management.xml para inicializar un nuevo motor de tenants de\nadministración de dispositivos para el tenant adicional. Cada vez que se modifican los archivos\ndentro de un tenant, los cambios se transmiten a motores tenants que se ejecutan en todos los otros\nmicroservicios para que puedan reaccionar a los cambios. En el ejemplo anterior, si se ejecutan varios\nmicroservicios de gestión de dispositivos (escala > 1), cada microservicio detectará las actualizaciones\ny volverá a cargar los motores de tenants para reflejar las actualizaciones.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"web-rest"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#web-rest","aria-hidden":"true"}},[this._v("#")]),this._v(" Web/REST")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("Puede haber casos donde el microservicio requerido para completar una solicitud no está disponible.\nEn este caso, se lanza una excepción "),a("em",[this._v("ServiceNotAvailable")]),this._v(" y se devuelve como un error al\nusuario/aplicación que realizó la solicitud. Usando este enfoque, las áreas del sistema pueden\ncerrarse para conservar recursos sin afectar la funcionalidad del sistema en su conjunto.\nLas personas que llaman a los servicios REST deben estar preparadas para manejar los casos\nen los que el subsistema que están llamando se cierre.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"device-management"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#device-management","aria-hidden":"true"}},[this._v("#")]),this._v(" Device Management")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de administración de dispositivos multitenant ("),a("em",[this._v("device management")]),this._v(') proporciona las API principales\ny la persistencia de datos para administrar el modelo de dispositivo (sitios, especificaciones,\ndispositivos, grupos, etc.) para cada inquilino en una instancia de SiteWhere. El modelo de dispositivo\nse llena inicialmente en base a los scripts incluidos en la plantilla de inquilino utilizada al crear el\ntenant. Por ejemplo, la plantilla "Construcción" rellenará el modelo de datos con dispositivos apropiados\npara un sitio de construcción. Si usa la plantilla "Vacío", no se completarán los datos de gestión del dispositivo.')])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"event-management"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#event-management","aria-hidden":"true"}},[this._v("#")]),this._v(" Event Management")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de administración de eventos multitenant ("),a("em",[this._v("event management")]),this._v(') proporciona\nlas API centrales y la persistencia de datos para administrar eventos de dispositivos\n(ubicaciones, mediciones, alertas, invocaciones de comandos, etc.) para cada tenant en\nuna instancia de SiteWhere. El modelo de evento del dispositivo se llena inicialmente\nen función de los scripts incluidos en la plantilla de inquilino utilizada al crear el tenant.\nPor ejemplo, la plantilla "Construcción" rellena ejemplos de ubicación, medición y datos de alerta\nrelevantes para máquinas en un sitio de construcción. Si utiliza la plantilla "Vacío", no se completarán\nlos datos de gestión de eventos.')])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"asset-management"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#asset-management","aria-hidden":"true"}},[this._v("#")]),this._v(" Asset Management")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de administración de activos multitenant ("),a("em",[this._v("asset management")]),this._v(') proporciona\nlas API centrales y la persistencia de los datos para administrar los activos de cada tenant\nen una instancia de SiteWhere. El modelo de activos se rellena inicialmente en función de\nlos scripts incluidos en la plantilla de inquilino utilizada al crear el tenant. Por ejemplo,\nla plantilla "Construcción" rellena elementos tales como equipos pesados, remolques de almacenamiento\ny varios tipos de dispositivos de seguimiento. Si usa la plantilla "Vaciar", no se completarán\ndatos de gestión de activos.')])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"schedule-management"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#schedule-management","aria-hidden":"true"}},[this._v("#")]),this._v(" Schedule Management")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de administración de cronograma multitenant ("),a("em",[this._v("schedule management")]),this._v(') proporciona\nlas API principales y la persistencia de datos para administrar las planificaciones de cada tenant\nen una instancia de SiteWhere. El modelo de cronograma se llena inicialmente en base a los scripts\nincluidos en la plantilla de inquilino utilizada al crear el tenant. La mayoría de las plantillas de\ntenants incluyen algunos horarios de ejemplo. Si usa la plantilla "Vaciar", no se completarán los\ndatos de gestión de programación.')])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"batch-operations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#batch-operations","aria-hidden":"true"}},[this._v("#")]),this._v(" Batch Operations")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de operaciones batch multitenant ("),a("em",[this._v("batch operations")]),this._v(") proporciona las API principales\ny la persistencia de datos para administrar las operaciones por lotes para cada tenant en una instancia\nde SiteWhere. El modelo de operaciones por lotes está vacío en la inicialización del tenant, pero puede\ncompletarse invocando las API que producen operaciones por lotes (como invocaciones de comandos por lotes).")])},function(){var e=this.$createElement,a=this._self._c||e;return a("div",{staticClass:"warning custom-block"},[a("p",{staticClass:"custom-block-title"},[this._v("ADVERTENCIA")]),this._v(" "),a("p",[this._v("Este microservicio no está completamente implementado en 2.0")])])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"event-sources"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#event-sources","aria-hidden":"true"}},[this._v("#")]),this._v(" Event Sources")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de fuentes de eventos multitenant ("),a("em",[this._v("event sources")]),this._v(") aloja motores de tenants\nque pueden configurarse para ingerir datos de muchos tipos de productores de datos.\nAlgunos ejemplos incluyen consumir datos de temas MQTT, solicitudes CoAP, conexiones directas de socket\nTCP/IP, WebSockets, llamadas REST a través de modelos push o pull y muchas otras fuentes potenciales.\nDespués de ingerir los eventos, se decodifican en un modelo de datos estandarizado y se envían a un\ntopic de Kafka específico del tenant para su posterior procesamiento. Los topics de Kafka también se\nregistran para eventos que no se pueden analizar o se detectan como duplicados mediante el\nprocesamiento de deduplicación.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"inbound-processing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#inbound-processing","aria-hidden":"true"}},[this._v("#")]),this._v(" Inbound Processing")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de procesamiento entrante multitenant ("),a("em",[this._v("inbound processing")]),this._v(") ingesta datos\nproducidos por el microservicio de fuentes de eventos (después de que la decodificación y\ndeduplicación se hayan completado). Este microservicio valida los datos entrantes al\ninteractuar con el servicio de microservicio de administración de dispositivos para verificar\nque el evento entrante se relaciona con un dispositivo registrado. La carga útil entrante se\nenriquece con los datos del dispositivo/asignación, por lo que la información puede ser\nutilizada por pasos de procesamiento posteriores sin necesidad de volver a buscarla.\nSi el dispositivo no está registrado, la carga se pasa al microservicio de registro del dispositivo\npara un procesamiento adicional. Si el dispositivo se registra como resultado, el evento se inserta\nen un topic de reprocesamiento para que pueda procesarse nuevamente con el dispositivo recién registrado.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"device-registration"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#device-registration","aria-hidden":"true"}},[this._v("#")]),this._v(" Device Registration")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de registro de dispositivos multitenant ("),a("em",[this._v("device registration")]),this._v(")\ningiere datos de un topic de Kafka poblado por el microservicio de procesamiento de\nentrada cuando los eventos hacen referencia a una identificación de hardware para un\ndispositivo que no está actualmente registrado en el sistema. Cada motor de inquilino\ntiene un administrador de registro de dispositivo que puede configurarse para indicar\ncómo se tratarán los dispositivos no registrados. El administrador de registro del dispositivo\nprocesa cada evento entrante y puede potencialmente registrar el dispositivo automáticamente\nantes de agregar el evento a un topic de reprocesamiento para que lo procese el microservicio\nde procesamiento de entrada.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"rule-processing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rule-processing","aria-hidden":"true"}},[this._v("#")]),this._v(" Rule Processing")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de procesamiento de reglas multitenant ("),a("em",[this._v("rule processing")]),this._v(") ingiere datos del topic\nde Kafka que contienen eventos preprocesados y aplica la lógica condicional para seguir procesando los eventos.\nLos motores de tenants pueden usar el procesamiento de eventos complejos integrado (WSO2 Siddhi) para\ndetectar patrones en la secuencia de eventos y generar nuevos eventos como resultado.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("div",{staticClass:"warning custom-block"},[a("p",{staticClass:"custom-block-title"},[this._v("ADVERTENCIA")]),this._v(" "),a("p",[this._v("Este microservicio no está completamente implementado en 2.0")])])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"command-delivery"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#command-delivery","aria-hidden":"true"}},[this._v("#")]),this._v(" Command Delivery")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El servicio de microservicio de entrega de comandos multitenant ("),a("em",[this._v("command delivery")]),this._v(") ingiere\ndatos del topic de Kafka que contienen eventos preprocesados y, para invocaciones de comandos,\nmaneja el procesamiento de comandos. Esto incluye el uso de restricciones de enrutamiento configuradas\ny destinos de comando que indican cómo se codificará el comando, qué transporte se utilizará\ny dónde se entregará el comando.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"outbound-connectors"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#outbound-connectors","aria-hidden":"true"}},[this._v("#")]),this._v(" Outbound Connectors")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de conectores de salida multitenant ("),a("em",[this._v("outbound connectors")]),this._v(") ingesta datos del topic\nde Kafka que contienen eventos preprocesados ​​y permite que los datos del evento se reenvíen a otros\npuntos de integración de forma asincrónica. Cada conector de salida es un consumidor de Kafka que tiene\nsu propio puntero en el topic de los eventos, por lo que el sistema no está bloqueado por conectores\nque ocasionalmente procesan a tasas más lentas que el resto del sistema. Los conectores están\ndisponibles para casos de uso común, como el reenvío de eventos a un topic bien conocido de MQTT o\neventos de indexación en Apache Solr.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"presence-management"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#presence-management","aria-hidden":"true"}},[this._v("#")]),this._v(" Presence Management")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de gestión de presencia multitenant ("),a("em",[this._v("presence management")]),this._v(") ingiere datos del topic\nde Kafka que contienen eventos preprocesados ​​y utiliza los datos de eventos para actualizar el estado\nde presencia del dispositivo. Cada motor de inquilino tiene un administrador de presencia de\ndispositivo que es responsable de determinar cuándo los dispositivos ya no están presentes y de\nactivar eventos de cambio de estado que pueden usarse para desencadenar acciones basadas en la\npresencia o no presencia de un dispositivo.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"label-generation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#label-generation","aria-hidden":"true"}},[this._v("#")]),this._v(" Label Generation")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de generación de etiquetas multitenant ("),a("em",[this._v("label generation")]),this._v(") responde a las\nsolicitudes API de recursos de etiquetas, como códigos QR, códigos de barras o etiquetas de\ndispositivos personalizados. Cada motor de inquilino tiene un administrador de generación de\nsímbolos que puede personalizarse para generar tipos específicos de resultados únicos para el inquilino.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"event-search"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#event-search","aria-hidden":"true"}},[this._v("#")]),this._v(" Event Search")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de búsqueda de eventos multitenant ("),a("em",[this._v("event search")]),this._v(") proporciona una API para\nbuscar fuentes de datos externas que contienen información de eventos de SiteWhere en un formato\nno estándar. Por ejemplo, cuando los eventos se indexan en Apache Solr a través de un conector de salida,\npuede haber una necesidad de consultar Solr directamente para hacer consultas complejas facetadas\nque no pueden ser genéricamente compatibles a través de las API de SiteWhere. Los motores de inquilino\npara este microservicio pueden configurarse para enviar consultas proxy al servicio subyacente y\ndevolver los resultados al servicio de microservicio Web/REST para que los usen los clientes externos.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("div",{staticClass:"warning custom-block"},[a("p",{staticClass:"custom-block-title"},[this._v("ADVERTENCIA")]),this._v(" "),a("p",[this._v("Este microservicio no está completamente implementado en 2.0")])])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"streaming-media"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#streaming-media","aria-hidden":"true"}},[this._v("#")]),this._v(" Streaming Media")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de transmisión multimedia multitenant ("),a("em",[this._v("streaming media")]),this._v(") está diseñado para\npermitir el almacenamiento en tiempo real de datos binarios, como transmisiones de audio y video.\nAlgunas API básicas para la transmisión estaban disponibles en SiteWhere 1.x, pero no estaban\ndocumentadas ni se consideraban de calidad de producción. SiteWhere 2.0 formalizará las API de\nmedios de transmisión, aunque la integración con varias tecnologías de codificación/decodificación\npuede extenderse más allá del ciclo de publicación de 2.0 GA.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("div",{staticClass:"warning custom-block"},[a("p",{staticClass:"custom-block-title"},[this._v("ADVERTENCIA")]),this._v(" "),a("p",[this._v("Este microservicio no está completamente implementado en 2.0")])])}],!1,null,null,null);n.options.__file="microservice-overview.md";a.default=n.exports}}]);