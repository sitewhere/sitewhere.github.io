(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{198:function(e,a,i){"use strict";i.r(a);var t=i(1),s=Object(t.a)({},function(){var e=this,a=e.$createElement,i=e._self._c||a;return i("div",{staticClass:"content"},[e._m(0),e._v(" "),e._m(1),e._v(" "),i("InlineImage",{attrs:{src:"/images/platform/microservices-diagram.png",caption:"Microservices"}}),e._v(" "),e._m(2),e._v(" "),i("p",[e._v("Todos los microservicios de SiteWhere se basan en una biblioteca personalizada definida en\nel módulo "),i("a",{attrs:{href:"https://github.com/sitewhere/sitewhere/tree/sitewhere-2.0.0/sitewhere-microservice",target:"_blank",rel:"noopener noreferrer"}},[e._v("sitewhere-microservice"),i("OutboundLink")],1),e._v("\ndel repositorio central de SiteWhere. Esta biblioteca incluye el código común utilizado\npor los microservicios de SiteWhere, incluido el ciclo de vida del servicio, la configuración,\nel registro, el descubrimiento del servicio, el rastreo distribuido y otras funcionalidades transversales.")]),e._v(" "),e._m(3),e._v(" "),i("p",[e._v("Los microservicios de SiteWhere se empaquetan como aplicaciones Spring Boot que utilizan una clase\nbase común "),i("a",{attrs:{href:"https://github.com/sitewhere/sitewhere/blob/sitewhere-2.0.0/sitewhere-microservice/src/main/java/com/sitewhere/microservice/MicroserviceApplication.java",target:"_blank",rel:"noopener noreferrer"}},[i("code",[e._v("MicroserviceApplication")]),i("OutboundLink")],1),e._v("\nque estandariza el comportamiento de inicio/apagado del servicio. La aplicación envuelve una subclase de la instancia\nde un "),i("a",{attrs:{href:"https://github.com/sitewhere/sitewhere/blob/sitewhere-2.0.0/sitewhere-microservice/src/main/java/com/sitewhere/microservice/Microservice.java",target:"_blank",rel:"noopener noreferrer"}},[i("code",[e._v("Microservice")]),i("OutboundLink")],1),e._v("\nque implementa gran parte del comportamiento común, como el ciclo de vida del microservicio, el descubrimiento del servicio,\nlos servicios Kafka y gRPC comunes, así como enlaces para los comportamientos del ciclo de vida estándar.\nLas subclases de microservicio utilizan los distintos ganchos ("),i("em",[e._v("hooks")]),e._v(") para personalizar el ciclo de vida y agregar nuevas funcionalidades.")]),e._v(" "),e._m(4),e._v(" "),e._m(5),e._v(" "),e._m(6),e._v(" "),e._m(7),e._v(" "),e._m(8),e._v(" "),e._m(9),e._v(" "),e._m(10),e._v(" "),i("p",[e._v("Los microservicios no funcionan en un vacío y, como tal, se necesita un mecanismo RPC de alto\nrendimiento para permitir que los servicios se comuniquen. SiteWhere aprovecha "),i("a",{attrs:{href:"https://grpc.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("gRPC"),i("OutboundLink")],1),e._v("\npara mover datos entre microservicios y ofrece API binarias de rendimiento para consumidores externos.\nTodas las llamadas a la API y las entidades de datos se han puesto a disposición de gRPC a través de Google\n"),i("em",[e._v("Protocol Buffers")]),e._v(". Usar gRPC en lugar de REST para la comunicación puede aumentar el rendimiento de la API en más de 10x.")]),e._v(" "),e._m(11),e._v(" "),i("p",[e._v("Las conexiones entre microservicios no siempre son uno a uno. Por ejemplo, si una instancia de SiteWhere tiene un solo\nmicroservicio Web/REST y tres instancias del microservicio de gestión de dispositivos, el microservicio de REST debería\nser capaz de demultiplexar llamadas en las tres instancias de gestión de dispositivos para la escalabilidad y la\ntolerancia a fallos. SiteWhere 2.0 introduce el concepto de un demulitplexor de API que puede realizar una\nintrospección de la topología de instancia actual y agregar/eliminar conexiones a otros microservicios\nde forma dinámica. A medida que la cantidad de servicios aumenta o disminuye, SiteWhere conecta/desconecta\nautomáticamente la tubería entre ellos. Toda la comunicación entre microservicios ocurre a través de este mecanismo.")]),e._v(" "),e._m(12),e._v(" "),i("p",[e._v("Incluso con el alto rendimiento de gRPC, solicitar un uso frecuente de datos repetidamente a través de la\nconexión de red tiene un costo significativo. La información maestra para entidades como dispositivos,\nasignaciones y activos rara vez se actualiza y puede almacenarse localmente en el microservicio en\nlugar de incurrir en el costo de la lectura de la base de datos. SiteWhere 2.0 utiliza un "),i("a",{attrs:{href:"https://www.ehcache.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("ehCache"),i("OutboundLink")],1),e._v("\npara proporcionar un caché local de un subconjunto de datos maestros. Este caché se consulta antes de\nrecurrir a una solicitud gRPC remota.")]),e._v(" "),e._m(13),e._v(" "),i("p",[e._v("Los microservicios de SiteWhere hacen algunas suposiciones sobre la infraestructura subyacente en la que se ejecutan.\nComo mínimo, las instancias de "),i("a",{attrs:{href:"https://zookeeper.apache.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Apache ZooKeeper"),i("OutboundLink")],1),e._v(", "),i("a",{attrs:{href:"https://kafka.apache.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Apache Kafka"),i("OutboundLink")],1),e._v("\ny "),i("a",{attrs:{href:"https://www.consul.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Hashicorp Consul"),i("OutboundLink")],1),e._v(" deben estar disponible para que el sistema funcione correctamente.\nDe forma predeterminada, SiteWhere también produce datos de seguimiento distribuidos a través del estándar\n"),i("a",{attrs:{href:"http://opentracing.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("OpenTracing"),i("OutboundLink")],1),e._v(" para el análisis del rendimiento en tiempo de ejecución.\nUn servidor backend que soporta la API puede configurarse para almacenar y analizar los datos.")]),e._v(" "),e._m(14),e._v(" "),i("p",[e._v("A continuación se muestra una lista de los microservicios principales incluidos\nen SiteWhere 2.0. Cada servicio maneja un área específica de la funcionalidad\ndel sistema y es independiente de otros microservicios en términos de procesamiento\nde tiempo de ejecución, almacenamiento y configuración de datos. Sin embargo,\nalgunos microservicios tienen dependencias en las API que ofrecen otros servicios\ny no pueden ejecutarse de forma aislada. A continuación hay una descripción\ngeneral de alto nivel de los servicios individuales junto con enlaces a explicaciones\nmás detalladas de cada servicio.")]),e._v(" "),e._m(15),e._v(" "),e._m(16),e._v(" "),i("p",[e._v("Consulte la "),i("router-link",{attrs:{to:"./../guide/microservices/instance-management.html"}},[e._v("guía")]),e._v(" de gestión de instancias\npara más detalles.")],1),e._v(" "),e._m(17),e._v(" "),e._m(18),e._v(" "),e._m(19),e._v(" "),e._m(20),e._v(" "),e._m(21),e._v(" "),e._m(22),e._v(" "),i("p",[e._v("El microservicio Web/REST global incluye un contenedor Tomcat que proporciona infraestructura\npara todos los servicios REST básicos (incluidas las interfaces de usuario de Swagger).\nEste microservicio generalmente está conectado a todos los demás microservicios en el\nsistema, de modo que las llamadas API pueden delegarse a los microservicios que implementan\nla funcionalidad. Por ejemplo, consultar un dispositivo a través de las API REST da como\nresultado una solicitud gRPC (potencialmente almacenada en caché a través de Hazelcast)\nen el motor de inquilino de gestión de dispositivos apropiado en uno de los microservicios de\ngestión de dispositivos.")]),e._v(" "),e._m(23),e._v(" "),e._m(24),e._v(" "),e._m(25),e._v(" "),e._m(26),e._v(" "),e._m(27),e._v(" "),e._m(28),e._v(" "),e._m(29),e._v(" "),e._m(30),e._v(" "),e._m(31),e._v(" "),e._m(32),e._v(" "),e._m(33),e._v(" "),i("p",[e._v("Cada motor de tenant de operaciones por lotes también contiene un administrador de operaciones por\nlotes que puede configurarse para procesar las operaciones por lotes que se crean a través de las API.\nEl administrador de operaciones por lotes convertirá la solicitud del lote en muchas operaciones más\npequeñas para lograr el objetivo del lote.")]),e._v(" "),e._m(34),e._v(" "),e._m(35),e._v(" "),e._m(36),e._v(" "),e._m(37),e._v(" "),i("p",[e._v("Una vez que el evento entrante se ha enriquecido, se reenvía al microservicio de gestión de eventos\npara su persistencia. El evento persistente se devuelve (asincrónicamente) eventualmente al procesamiento\nentrante donde se agrega a un topic para eventos preprocesados ​​que a su vez pueden ser consumidos por otros\nmicroservicios, tales como el procesamiento de reglas y los conectores salientes.")]),e._v(" "),e._m(38),e._v(" "),e._m(39),e._v(" "),i("p",[e._v('Los eventos que no dan como resultado el registro automático de un dispositivo son llevados a\nun topic de "letra muerta" en Kafka para que los procesadores externos puedan rastrearlos\no procesarlos fuera de banda.')]),e._v(" "),e._m(40),e._v(" "),e._m(41),e._v(" "),e._m(42),e._v(" "),e._m(43),e._v(" "),e._m(44),e._v(" "),e._m(45),e._v(" "),e._m(46),e._v(" "),e._m(47),e._v(" "),e._m(48),e._v(" "),e._m(49),e._v(" "),e._m(50),e._v(" "),e._m(51),e._v(" "),e._m(52),e._v(" "),e._m(53),e._v(" "),e._m(54)],1)},[function(){var e=this.$createElement,a=this._self._c||e;return a("h1",{attrs:{id:"descripcion-de-los-microservicios"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#descripcion-de-los-microservicios","aria-hidden":"true"}},[this._v("#")]),this._v(" Descripción de los Microservicios")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("Una instancia de SiteWhere consta de muchos microservicios, cada uno de los cuales maneja una\npieza específica de funcionalidad. Tras el despliegue, los microservicios se organizan en un\nsistema distribuido sobre la infraestructura de Kubernetes. Se utiliza un "),a("em",[this._v("Helm chart")]),this._v(" para\nconfigurar la lista de microservicios de SiteWhere y otros componentes que deben iniciarse\npara realizar una configuración determinada. Una vez iniciados, los microservicios se\nautoensamblan y luego se ponen a disposición de las tareas de procesamiento.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h2",{attrs:{id:"estructura-de-microservicios"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#estructura-de-microservicios","aria-hidden":"true"}},[this._v("#")]),this._v(" Estructura de Microservicios")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"aplicacion-spring-boot"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aplicacion-spring-boot","aria-hidden":"true"}},[this._v("#")]),this._v(" Aplicación Spring Boot")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("La biblioteca de microservicios de SiteWhere utiliza la configuración del entorno Spring Boot para configurar\ndiversos aspectos de cada microservicio. La configuración puede sobreescribirse inyectando variables de entorno\nal desplegar los microservicios. El "),a("em",[this._v("Helm chart")]),this._v(" predeterminado para SiteWhere lo maneja de forma transparente,\npero puede haber casos en que los valores deban ser sobrescritos manualmente. La siguiente tabla cubre la lista\nde configuraciones de entorno estándar de toda la instancia:")])},function(){var e=this,a=e.$createElement,i=e._self._c||a;return i("table",[i("thead",[i("tr",[i("th",{staticStyle:{"text-align":"left"}},[e._v("Configuración")]),e._v(" "),i("th",{staticStyle:{"text-align":"left"}},[e._v("Por defecto")]),e._v(" "),i("th",{staticStyle:{"text-align":"left"}},[e._v("Descripción")])])]),e._v(" "),i("tbody",[i("tr",[i("td",{staticStyle:{"text-align":"left"}},[e._v("sitewhere.product.id")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("sitewhere")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("Nombre del nodo de nivel superior en el árbol Zookeeper.")])]),e._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[e._v("sitewhere.instance.id")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("sitewhere1")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("Nombre de instancia utilizado en Zookeeper y Kafka nombre del "),i("em",[e._v("topic")]),e._v(".")])]),e._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[e._v("sitewhere.instance.template.id")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("default")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("Plantilla de gestión de instancias utilizada para inicializar inquilinos y usuarios del sistema.")])]),e._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[e._v("sitewhere.consul.host")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("consul")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("Nombre de host usado para contactar a Consul para el descubrimiento del servicio.")])]),e._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[e._v("sitewhere.consul.port")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("8080")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("Puerto usado para contactar al Cónsul para el descubrimiento del servicio.")])]),e._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[e._v("sitewhere.zookeeper.host")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("localhost")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("Nombre de host usado para contactar a Zookeeper para la configuración.")])]),e._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[e._v("sitewhere.zookeeper.port")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("2181")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("Puerto utilizado para contactar con Zookeeper para la configuración.")])]),e._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[e._v("sitewhere.kafka.bootstrap.servers")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("kafka:9092")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("Lista de servidores Kafka de inicio.")])]),e._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[e._v("sitewhere.filesystem.storage.root")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("/var/sitewhere")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("Raíz del sistema de archivos para microservicios que persisten los datos localmente para el almacenamiento en caché.")])]),e._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[e._v("sitewhere.grpc.port")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("9000")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("Puerto utilizado para exponer API gRPC específicas de microservicio.")])]),e._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[e._v("sitewhere.management.grpc.port")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("9001")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("Puerto utilizado para exponer la interfaz de gestión gRPC.")])]),e._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[e._v("sitewhere.tracer.server")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("jaeger")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("Nombre de host utilizado para publicar la salida de seguimiento distribuido.")])]),e._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[e._v("sitewhere.log.metrics")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("false")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("Indica si las métricas deben registrarse para el microservicio.")])]),e._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[e._v("sitewhere.k8s.pod.ip")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("null")]),e._v(" "),i("td",{staticStyle:{"text-align":"left"}},[e._v("Inyectado para que el microservicio sepa su IP de pod Kubernetes.")])])])])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"imagen-base-de-docker"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#imagen-base-de-docker","aria-hidden":"true"}},[this._v("#")]),this._v(" Imagen Base de Docker")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("Todos los microservicios de SiteWhere se construyen sobre la misma imagen base de Docker para reducir\nla sobrecarga de tiempo de ejecución de las imágenes. La imagen "),a("code",[this._v("openjdk: 8-jre-alpine")]),this._v(" se usa actualmente\ndebido a su pequeña huella que incluye el "),a("em",[this._v("runtime")]),this._v(" de Java 8 necesario para ejecutar las aplicaciones.\nHay planes futuros para aprovechar las características de Java 9 para reducir aún más los tamaños de imagen\ny los requisitos de tiempo de ejecución para los microservicios.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"utilizacion-de-recursos-del-sistema"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#utilizacion-de-recursos-del-sistema","aria-hidden":"true"}},[this._v("#")]),this._v(" Utilización de Recursos del Sistema")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("Actualmente, SiteWhere utiliza alrededor de 20 microservicios, por lo que el hardware subyacente debe ser\ncompatible con la ejecución de 20 procesos Java simultáneos, cada uno con una huella de memorua de alrededor\nde 500 MB. Los requisitos son significativos, aunque la mayoría de las computadoras de escritorio modernas\npueden ejecutar fácilmente un sistema completo. El "),a("em",[this._v("Helm Chart")]),this._v(" de SiteWhere Helm incluye un perfil "),a("code",[this._v("mínimo")]),this._v("\nque solo carga los microservicios necesarios para reducir los requisitos de recursos. Sin embargo,\nla intención de SiteWhere 2.0 es distribuir los componentes del sistema en un grupo de máquinas,\nlo que reduce los requisitos de hardware para un solo nodo y aumenta la tolerancia a fallos.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h2",{attrs:{id:"conectividad-intra-microservicios"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#conectividad-intra-microservicios","aria-hidden":"true"}},[this._v("#")]),this._v(" Conectividad Intra-Microservicios")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"demultiplexores-de-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#demultiplexores-de-api","aria-hidden":"true"}},[this._v("#")]),this._v(" Demultiplexores de API")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"soporte-api-cache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#soporte-api-cache","aria-hidden":"true"}},[this._v("#")]),this._v(" Soporte API Cache")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h2",{attrs:{id:"components-de-la-infraestructura"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#components-de-la-infraestructura","aria-hidden":"true"}},[this._v("#")]),this._v(" Components de la Infraestructura")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h2",{attrs:{id:"lista-de-princiaples-microservicios"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lista-de-princiaples-microservicios","aria-hidden":"true"}},[this._v("#")]),this._v(" Lista de Princiaples Microservicios")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"instance-management"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#instance-management","aria-hidden":"true"}},[this._v("#")]),this._v(" Instance Management")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de gestión de instancias ("),a("em",[this._v("instance management")]),this._v(") se utiliza para iniciar una instancia\nde SiteWhere con la estructura de configuración inicial de Zookeeper requerida\npor los otros microservicios. Todos los demás microservicios esperan a que se\ninicialicen los datos de Zookeeper antes de comenzar, por lo que el microservicio\nde gestión de instancias debe estar presente en una instancia de SiteWhere no\niniciada o todos los demás microservicios no podrán iniciarse.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"user-management"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#user-management","aria-hidden":"true"}},[this._v("#")]),this._v(" User Management")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de administración de usuarios ("),a("em",[this._v("user management")]),this._v(") global proporciona las API principales\ny la persistencia de datos utilizada para administrar usuarios del sistema.\nInicialmente es utilizado por el microservicio de gestión de instancias ("),a("em",[this._v("instance management")]),this._v(")\npara arrancar el sistema con los usuarios base. Posteriormente, el servicio Web/REST\nlo llama para permitir que se administre la lista de usuarios.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"tenant-management"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tenant-management","aria-hidden":"true"}},[this._v("#")]),this._v(" Tenant Management")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio gobal de administración de "),a("em",[this._v("tenants")]),this._v(" ("),a("em",[this._v("tenant management")]),this._v(") proporciona\nlas API centrales y la persistencia de datos para administrar a los tenants del sistema.\nInicialmente, el microservicio de gestión de instancias lo utiliza para iniciar el sistema con los\ntenants base. Posteriormente, el microservicio Web/REST lo llama para permitir que se administre\nla lista de tenants del sistema.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("Cuando se agrega/actualiza/borra un tenant, los datos del tenant se envían a un "),a("em",[this._v("topic")]),this._v(" de Kafka\npara que otros oyentes interesados ​​puedan actuar sobre la actualización. De forma predeterminada,\nun oyente se registra para impulsar a los tenants recién creados al agregar la jerarquía de\nconfiguración de tenant esperada en ZooKeeper. Este proceso incluye copiar los archivos de\nconfiguración XML por microservicio de la plantilla de tenant en ZooKeeper, y luego ejecutar\nla lista de scripts de inicialización incluidos con la plantilla. Una vez que se completa este proceso,\nla configuración del tenant se marca como boostrapped para que otros microservicios puedan reaccionar\nante el tenant adicional. Por ejemplo, el servicio de microservicio de administración de dispositivos\nnotará que se ha configurado un nuevo tenant y esperará el indicador bootstrapped, luego cargará el\nrchivo de configuración device-management.xml para inicializar un nuevo motor de tenants de\nadministración de dispositivos para el tenant adicional. Cada vez que se modifican los archivos\ndentro de un tenant, los cambios se transmiten a motores tenants que se ejecutan en todos los otros\nmicroservicios para que puedan reaccionar a los cambios. En el ejemplo anterior, si se ejecutan varios\nmicroservicios de gestión de dispositivos (escala > 1), cada microservicio detectará las actualizaciones\ny volverá a cargar los motores de tenants para reflejar las actualizaciones.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"web-rest"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#web-rest","aria-hidden":"true"}},[this._v("#")]),this._v(" Web/REST")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("Puede haber casos donde el microservicio requerido para completar una solicitud no está disponible.\nEn este caso, se lanza una excepción "),a("em",[this._v("ServiceNotAvailable")]),this._v(" y se devuelve como un error al\nusuario/aplicación que realizó la solicitud. Usando este enfoque, las áreas del sistema pueden\ncerrarse para conservar recursos sin afectar la funcionalidad del sistema en su conjunto.\nLas personas que llaman a los servicios REST deben estar preparadas para manejar los casos\nen los que el subsistema que están llamando se cierre.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"device-management"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#device-management","aria-hidden":"true"}},[this._v("#")]),this._v(" Device Management")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de administración de dispositivos multitenant ("),a("em",[this._v("device management")]),this._v(') proporciona las API principales\ny la persistencia de datos para administrar el modelo de dispositivo (sitios, especificaciones,\ndispositivos, grupos, etc.) para cada inquilino en una instancia de SiteWhere. El modelo de dispositivo\nse llena inicialmente en base a los scripts incluidos en la plantilla de inquilino utilizada al crear el\ntenant. Por ejemplo, la plantilla "Construcción" rellenará el modelo de datos con dispositivos apropiados\npara un sitio de construcción. Si usa la plantilla "Vacío", no se completarán los datos de gestión del dispositivo.')])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"event-management"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#event-management","aria-hidden":"true"}},[this._v("#")]),this._v(" Event Management")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de administración de eventos multitenant ("),a("em",[this._v("event management")]),this._v(') proporciona\nlas API centrales y la persistencia de datos para administrar eventos de dispositivos\n(ubicaciones, mediciones, alertas, invocaciones de comandos, etc.) para cada tenant en\nuna instancia de SiteWhere. El modelo de evento del dispositivo se llena inicialmente\nen función de los scripts incluidos en la plantilla de inquilino utilizada al crear el tenant.\nPor ejemplo, la plantilla "Construcción" rellena ejemplos de ubicación, medición y datos de alerta\nrelevantes para máquinas en un sitio de construcción. Si utiliza la plantilla "Vacío", no se completarán\nlos datos de gestión de eventos.')])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"asset-management"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#asset-management","aria-hidden":"true"}},[this._v("#")]),this._v(" Asset Management")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de administración de activos multitenant ("),a("em",[this._v("asset management")]),this._v(') proporciona\nlas API centrales y la persistencia de los datos para administrar los activos de cada tenant\nen una instancia de SiteWhere. El modelo de activos se rellena inicialmente en función de\nlos scripts incluidos en la plantilla de inquilino utilizada al crear el tenant. Por ejemplo,\nla plantilla "Construcción" rellena elementos tales como equipos pesados, remolques de almacenamiento\ny varios tipos de dispositivos de seguimiento. Si usa la plantilla "Vaciar", no se completarán\ndatos de gestión de activos.')])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"schedule-management"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#schedule-management","aria-hidden":"true"}},[this._v("#")]),this._v(" Schedule Management")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de administración de cronograma multitenant ("),a("em",[this._v("schedule management")]),this._v(') proporciona\nlas API principales y la persistencia de datos para administrar las planificaciones de cada tenant\nen una instancia de SiteWhere. El modelo de cronograma se llena inicialmente en base a los scripts\nincluidos en la plantilla de inquilino utilizada al crear el tenant. La mayoría de las plantillas de\ntenants incluyen algunos horarios de ejemplo. Si usa la plantilla "Vaciar", no se completarán los\ndatos de gestión de programación.')])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"batch-operations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#batch-operations","aria-hidden":"true"}},[this._v("#")]),this._v(" Batch Operations")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de operaciones batch multitenant ("),a("em",[this._v("batch operations")]),this._v(") proporciona las API principales\ny la persistencia de datos para administrar las operaciones por lotes para cada tenant en una instancia\nde SiteWhere. El modelo de operaciones por lotes está vacío en la inicialización del tenant, pero puede\ncompletarse invocando las API que producen operaciones por lotes (como invocaciones de comandos por lotes).")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"event-sources"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#event-sources","aria-hidden":"true"}},[this._v("#")]),this._v(" Event Sources")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de fuentes de eventos multitenant ("),a("em",[this._v("event sources")]),this._v(") aloja motores de tenants\nque pueden configurarse para ingerir datos de muchos tipos de productores de datos.\nAlgunos ejemplos incluyen consumir datos de temas MQTT, solicitudes CoAP, conexiones directas de socket\nTCP/IP, WebSockets, llamadas REST a través de modelos push o pull y muchas otras fuentes potenciales.\nDespués de ingerir los eventos, se decodifican en un modelo de datos estandarizado y se envían a un\ntopic de Kafka específico del tenant para su posterior procesamiento. Los topics de Kafka también se\nregistran para eventos que no se pueden analizar o se detectan como duplicados mediante el\nprocesamiento de deduplicación.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"inbound-processing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#inbound-processing","aria-hidden":"true"}},[this._v("#")]),this._v(" Inbound Processing")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de procesamiento entrante multitenant ("),a("em",[this._v("inbound processing")]),this._v(") ingesta datos\nproducidos por el microservicio de fuentes de eventos (después de que la decodificación y\ndeduplicación se hayan completado). Este microservicio valida los datos entrantes al\ninteractuar con el servicio de microservicio de administración de dispositivos para verificar\nque el evento entrante se relaciona con un dispositivo registrado. La carga útil entrante se\nenriquece con los datos del dispositivo/asignación, por lo que la información puede ser\nutilizada por pasos de procesamiento posteriores sin necesidad de volver a buscarla.\nSi el dispositivo no está registrado, la carga se pasa al microservicio de registro del dispositivo\npara un procesamiento adicional. Si el dispositivo se registra como resultado, el evento se inserta\nen un topic de reprocesamiento para que pueda procesarse nuevamente con el dispositivo recién registrado.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"device-registration"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#device-registration","aria-hidden":"true"}},[this._v("#")]),this._v(" Device Registration")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de registro de dispositivos multitenant ("),a("em",[this._v("device registration")]),this._v(")\ningiere datos de un topic de Kafka poblado por el microservicio de procesamiento de\nentrada cuando los eventos hacen referencia a una identificación del dispositivo ("),a("em",[this._v("deviceToken")]),this._v(")\npara un dispositivo que no está actualmente registrado en el sistema. Cada motor de inquilino\ntiene un administrador de registro de dispositivo que puede configurarse para indicar\ncómo se tratarán los dispositivos no registrados. El administrador de registro del dispositivo\nprocesa cada evento entrante y puede potencialmente registrar el dispositivo automáticamente\nantes de agregar el evento a un topic de reprocesamiento para que lo procese el microservicio\nde procesamiento de entrada.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"rule-processing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rule-processing","aria-hidden":"true"}},[this._v("#")]),this._v(" Rule Processing")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de procesamiento de reglas multitenant ("),a("em",[this._v("rule processing")]),this._v(") ingiere datos del topic\nde Kafka que contienen eventos preprocesados y aplica la lógica condicional para seguir procesando los eventos.\nLos motores de tenants pueden usar el procesamiento de eventos complejos integrado (WSO2 Siddhi) para\ndetectar patrones en la secuencia de eventos y generar nuevos eventos como resultado.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("div",{staticClass:"warning custom-block"},[a("p",{staticClass:"custom-block-title"},[this._v("ADVERTENCIA")]),this._v(" "),a("p",[this._v("Este microservicio no está completamente implementado en 2.0")])])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"command-delivery"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#command-delivery","aria-hidden":"true"}},[this._v("#")]),this._v(" Command Delivery")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El servicio de microservicio de entrega de comandos multitenant ("),a("em",[this._v("command delivery")]),this._v(") ingiere\ndatos del topic de Kafka que contienen eventos preprocesados y, para invocaciones de comandos,\nmaneja el procesamiento de comandos. Esto incluye el uso de restricciones de enrutamiento configuradas\ny destinos de comando que indican cómo se codificará el comando, qué transporte se utilizará\ny dónde se entregará el comando.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"outbound-connectors"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#outbound-connectors","aria-hidden":"true"}},[this._v("#")]),this._v(" Outbound Connectors")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de conectores de salida multitenant ("),a("em",[this._v("outbound connectors")]),this._v(") ingesta datos del topic\nde Kafka que contienen eventos preprocesados ​​y permite que los datos del evento se reenvíen a otros\npuntos de integración de forma asincrónica. Cada conector de salida es un consumidor de Kafka que tiene\nsu propio puntero en el topic de los eventos, por lo que el sistema no está bloqueado por conectores\nque ocasionalmente procesan a tasas más lentas que el resto del sistema. Los conectores están\ndisponibles para casos de uso común, como el reenvío de eventos a un topic bien conocido de MQTT o\neventos de indexación en Apache Solr.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"presence-management"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#presence-management","aria-hidden":"true"}},[this._v("#")]),this._v(" Presence Management")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de gestión de presencia multitenant ("),a("em",[this._v("presence management")]),this._v(") ingiere datos del topic\nde Kafka que contienen eventos preprocesados ​​y utiliza los datos de eventos para actualizar el estado\nde presencia del dispositivo. Cada motor de inquilino tiene un administrador de presencia de\ndispositivo que es responsable de determinar cuándo los dispositivos ya no están presentes y de\nactivar eventos de cambio de estado que pueden usarse para desencadenar acciones basadas en la\npresencia o no presencia de un dispositivo.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"label-generation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#label-generation","aria-hidden":"true"}},[this._v("#")]),this._v(" Label Generation")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de generación de etiquetas multitenant ("),a("em",[this._v("label generation")]),this._v(") responde a las\nsolicitudes API de recursos de etiquetas, como códigos QR, códigos de barras o etiquetas de\ndispositivos personalizados. Cada motor de inquilino tiene un administrador de generación de\nsímbolos que puede personalizarse para generar tipos específicos de resultados únicos para el inquilino.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"event-search"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#event-search","aria-hidden":"true"}},[this._v("#")]),this._v(" Event Search")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de búsqueda de eventos multitenant ("),a("em",[this._v("event search")]),this._v(") proporciona una API para\nbuscar fuentes de datos externas que contienen información de eventos de SiteWhere en un formato\nno estándar. Por ejemplo, cuando los eventos se indexan en Apache Solr a través de un conector de salida,\npuede haber una necesidad de consultar Solr directamente para hacer consultas complejas facetadas\nque no pueden ser genéricamente compatibles a través de las API de SiteWhere. Los motores de inquilino\npara este microservicio pueden configurarse para enviar consultas proxy al servicio subyacente y\ndevolver los resultados al servicio de microservicio Web/REST para que los usen los clientes externos.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"streaming-media"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#streaming-media","aria-hidden":"true"}},[this._v("#")]),this._v(" Streaming Media")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("El microservicio de transmisión multimedia multitenant ("),a("em",[this._v("streaming media")]),this._v(") está diseñado para\npermitir el almacenamiento en tiempo real de datos binarios, como transmisiones de audio y video.\nAlgunas API básicas para la transmisión estaban disponibles en SiteWhere 1.x, pero no estaban\ndocumentadas ni se consideraban de calidad de producción. SiteWhere 2.0 formalizará las API de\nmedios de transmisión, aunque la integración con varias tecnologías de codificación/decodificación\npuede extenderse más allá del ciclo de publicación de 2.0 GA.")])}],!1,null,null,null);s.options.__file="microservice-overview.md";a.default=s.exports}}]);