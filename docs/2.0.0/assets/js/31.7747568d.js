(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{179:function(e,t,n){"use strict";n.r(t);var r=n(1),a=Object(r.a)({},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[e._m(0),e._v(" "),n("p",[e._v("SiteWhere has been designed from the ground up to take advantage of the latest\ntechnologies in order to scale efficiently to the loads expected in large IoT\nprojects. Rather than using a monolithic architecture, SiteWhere embraces\na completely distributed architecture using "),n("a",{attrs:{href:"https://kubernetes.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Kubernetes"),n("OutboundLink")],1),e._v("\nas the infrastructure and a variety of microservices to build out the system.\nThis approach allows customization and scaling at a fine-grained level\nso that the system may be tailored to many potential IoT use cases. SiteWhere\nis built with a framework approach using clearly defined APIs so that new\ntechnologies can easily be integrated as the IoT ecosystem evolves.")]),e._v(" "),e._m(1),e._v(" "),n("p",[e._v("SiteWhere is composed of Java-based microservices which are built as\n"),n("a",{attrs:{href:"https://www.docker.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker"),n("OutboundLink")],1),e._v(" images and deployed to Kubernetes for\norchestration. To simplify deployement, "),n("a",{attrs:{href:"https://helm.sh/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Helm"),n("OutboundLink")],1),e._v(" is used to\nprovide standard templates for various deployment scenarios. Helm\n"),n("a",{attrs:{href:"https://github.com/sitewhere/sitewhere-recipes/tree/master/charts",target:"_blank",rel:"noopener noreferrer"}},[e._v("charts"),n("OutboundLink")],1),e._v("\nare provided which supply all of the dependencies needed to run a complete\nSiteWhere instance, including both the microservices and infrastructure\ncomponents such as Apache Zookeeper, Kafka, Mosquitto MQTT broker,\nand other supporting technologies.")]),e._v(" "),e._m(2),e._v(" "),n("p",[e._v("SiteWhere 2.0 introduces a much different architectural approach than was used\nin the 1.x platform. While the core APIs are mostly unchanged, the system implementation\nhas moved from a monolithic structure to one based on microservices. This approach\nprovides a number of advantages over the previous architecture.")]),e._v(" "),e._m(3),e._v(" "),n("p",[e._v("Each microservice is a completely self-contained entity that has its\nown configuration schema, internal components, data persistence, and\ninteractions with the event processing pipeline. SiteWhere microservices\nare built on top of a custom microservice framework and run as separate\n"),n("a",{attrs:{href:"https://projects.spring.io/spring-boot/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Spring Boot"),n("OutboundLink")],1),e._v(" processes, each\ncontained in its own "),n("a",{attrs:{href:"https://www.docker.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker"),n("OutboundLink")],1),e._v(" image.")]),e._v(" "),n("p",[e._v("Separating the system logic into microservices allows the interactions\nbetween various areas of the system to be more clearly defined. This\ntransition has resulted in a more understandable and maintainable\nsystem and should continue to pay dividends as more features are added.")]),e._v(" "),e._m(4),e._v(" "),n("p",[e._v("The microservice architecture allows individual functional areas of the system to be scaled\nindependently or left out completely. In use cases where REST processing tends to\nbe a bottleneck, multiple REST microservices can be run concurrently to handle the load.\nConversely, services such as presence management that may not be required can be left\nout so that processing power can be dedicated to other aspects of the system.")]),e._v(" "),e._m(5),e._v(" "),e._m(6),e._v(" "),e._m(7),e._v(" "),n("p",[e._v("SiteWhere 2.0 moves system configuration from the filesystem into\n"),n("a",{attrs:{href:"https://zookeeper.apache.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Apache ZooKeeper"),n("OutboundLink")],1),e._v(" to allow for a centralized\napproach to configuration management. ZooKeeper contains a hierarchical structure\nwhich represents the configuration for one or more SiteWhere instances\nand all of the microservices that are used to realize them.")]),e._v(" "),n("p",[e._v("Each microservice has a direct connection to ZooKeeper and uses the\nhierarchy to determine its configuration at runtime. Microservices listen for changes\nto the configuration data and react dynamically to updates. No configuration\nis stored locally within the microservice, which prevents problems with\nkeeping services in sync as system configuration is updated.")]),e._v(" "),e._m(8),e._v(" "),n("p",[e._v("Since many of the system components such as Zookeeper, Kafka, and various\ndatabases require access to persistent storage, SiteWhere 2.0 uses\n"),n("a",{attrs:{href:"https://rook.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Rook.io"),n("OutboundLink")],1),e._v(" within Kubernetes to supply distributed,\nreplicated block storage that is resilient to hardware failures while\nstill offering good performance characteristics. As storage and throughput\nneeds increase over time, new storage devices can be made available\ndynamically. The underlying "),n("a",{attrs:{href:"https://ceph.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Ceph"),n("OutboundLink")],1),e._v(" architecture\nused by Rook.io can handle "),n("em",[e._v("exobytes")]),e._v(" of data while allowing data\nto be resilient to failures at the node, rack, or even datacenter level.")]),e._v(" "),e._m(9),e._v(" "),n("p",[e._v("With the dynamic nature of the microservices architecture, it is imporant\nfor microservices to be able to efficiently locate running instances of\nthe various other services they interact with. SiteWhere 2.0 leverages\n"),n("a",{attrs:{href:"https://www.consul.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Consul"),n("OutboundLink")],1),e._v(" for service discovery. Each microservice\nregisters with Consul and provides a steady stream of updates to the\n(potentially replicated) central store. As instances of microservices are\nadded or removed, SiteWhere dynamically adjusts connectivity to take\nadvantage of the available resources.")]),e._v(" "),e._m(10),e._v(" "),n("p",[e._v("The event processing pipeline in SiteWhere 2.0 has been completely redesigned and uses\n"),n("a",{attrs:{href:"https://kafka.apache.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Apache Kafka"),n("OutboundLink")],1),e._v(" to provide a resilient, high-performance\nmechanism for progressively processing device event data. Microservices can plug in to\nkey points in the event processing pipeline, reading data from well-known inbound topics,\nprocessing data, then sending data to well-known outbound topics. External entites that\nare interested in data at any point in the pipeline can act as consumers of the SiteWhere\ntopics to use the data as it moves through the system.")]),e._v(" "),e._m(11),e._v(" "),n("p",[e._v("In the SiteWhere 1.x architecture, the pipeline for outbound processing used a blocking\napproach which meant that any single outbound processor could block the outbound pipeline.\nIn SiteWhere 2.0, each outbound connector is a true Kafka consumer with its own offset\nmarker into the event stream. This mechanism allows for outbound processors to process data\nat their own pace without slowing down other processors. It also allows services to\nleverage Kafka's consumer groups to distribute load across multiple consumers and\nscale processing accordingly.")]),e._v(" "),n("p",[e._v('Using Kafka also has other advantages that are leveraged by SiteWhere. Since all data for\nthe distributed log is stored on disk, it is possible to "replay" the event stream based\non previously gathered data. This is extremely valuable for aspects such as debugging\nprocessing logic or load testing the system.')]),e._v(" "),e._m(12),e._v(" "),n("p",[e._v("While device event data generally flows in a pipeline from microservice to microservice on\nKafka topics, there are also API operations that need to occur in real time between the\nmicroservices. For instance, device management and event management functions are contained in\nseparate microservices, so as new events come in to the system, the inbound processing microservice\nneeds to interact with device management to look up existing devices in the system and event\nmanagement in order to persist the events to a datastore such as\n"),n("a",{attrs:{href:"http://cassandra.apache.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Apache Cassandra"),n("OutboundLink")],1),e._v(".")]),e._v(" "),e._m(13),e._v(" "),n("p",[e._v("Rather than solely using REST services based on HTTP 1.x, which tend to have significant\nconnection overhead, SiteWhere 2.0 uses "),n("a",{attrs:{href:"https://grpc.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("gRPC"),n("OutboundLink")],1),e._v(" to establish a long-lived\nconnection between microservices that need to communicate with each other. Since gRPC uses\npersistent HTTP2 connections, the overhead for interactions is greatly reduced, allowing\nfor decoupling without a significant performance penalty.")]),e._v(" "),n("p",[e._v("The entire SiteWhere data model has been captured in\n"),n("a",{attrs:{href:"https://developers.google.com/protocol-buffers/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Google Protocol Buffers"),n("OutboundLink")],1),e._v(" format so that\nit can be used within GRPC services. All of the SiteWhere APIs are now exposed directly as\ngRPC services as well, allowing for high-performance, low-latency access to what was previously\nonly accessible via REST. The REST APIs are still made available via the Web/REST microservice,\nbut they use the gRPC APIs underneath to provide a consistent approach to accessing data.")]),e._v(" "),n("p",[e._v("Since the number of instances of a given microservice can change over time as the service is\nscaled up or down, SiteWhere automatically handles the process of connecting/disconnecting the\ngRPC pipes between microservices. Each outbound gRPC client is demulitplexed across the pool\nof services that can satisfy the requests, allowing the requests to be processed in parallel.")]),e._v(" "),e._m(14),e._v(" "),n("p",[e._v('The SiteWhere 1.x approach to multitenancy was to use a separate "tenant engine" for each tenant.\nThe engine supported all tenant-specific tasks such as data persistence, event processing, etc.\nSince SiteWhere 2.0 has moved to a microservices architecture, the multitenant model has been\ndistributed as well. SiteWhere supports two types of microservices: global and multitenant.')]),e._v(" "),e._m(15),e._v(" "),n("p",[e._v("Global microservices do not handle tenant-specific tasks. These services handle aspects such\nas instance-wide user management and tenant management that are not specific to individual\nsystem tenants. The Web/REST microservice that supports the REST services and Swagger user\ninterface is also a global service, since supporting a separate web container for each tenant\nwould be cumbersome and would break existing SiteWhere 1.x applications. There is also a\nglobal instance management microservice that monitors various aspects of the entire instance\nand reports updates to the individual microservces via Kafka.")]),e._v(" "),e._m(16),e._v(" "),n("p",[e._v("Most of the SiteWhere 2.0 services are multitenant microservices which delegate traffic\nto tenant engines that do the actual processing. For instance, the inbound processing microservice\nactually consists of many inbound processing tenant engines, each of which is configured separately\nand can be started/stopped/reconfigured without affecting the other tenant engines.")]),e._v(" "),n("p",[e._v("The new approach to tenant engines changes the dynamics of SiteWhere event processing. It is now\npossible to stop a single tenant engine without the need for stopping tenant engines running in\nother microservices. For instance, inbound processing for a tenant can be stopped\nand reconfigured while the rest of the tenant pipeline continues processing. Since new\nevents can be allowed to stack up in Kafka, the tenant engine can be stopped, reconfigured,\nand restarted, then resume where it left off with no data loss.")])])},[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"sitewhere-architecture"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sitewhere-architecture","aria-hidden":"true"}},[this._v("#")]),this._v(" SiteWhere Architecture")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"kubernetes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes","aria-hidden":"true"}},[this._v("#")]),this._v(" Kubernetes")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"microservices"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#microservices","aria-hidden":"true"}},[this._v("#")]),this._v(" Microservices")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"separation-of-concerns"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#separation-of-concerns","aria-hidden":"true"}},[this._v("#")]),this._v(" Separation of Concerns")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"scale-what-you-need-leave-out-what-you-don-t"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#scale-what-you-need-leave-out-what-you-don-t","aria-hidden":"true"}},[this._v("#")]),this._v(" Scale What You Need. Leave Out What You Don't")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"instance-management"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#instance-management","aria-hidden":"true"}},[this._v("#")]),this._v(" Instance Management")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("The 2.0 architecture introduces the concept of a SiteWhere "),t("em",[this._v("instance")]),this._v(", which\nallows the distributed system to act as a cohesive unit with some aspects\naddressed at the global level. All of the microservices for a single SiteWhere\ninstance must be running on the same Kubernetes infrastucture, though the system\nmay be spread across tens or hundreds of machines to distribute the processing\nload.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"centralized-configuration-management-with-apache-zookeeper"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#centralized-configuration-management-with-apache-zookeeper","aria-hidden":"true"}},[this._v("#")]),this._v(" Centralized Configuration Management with Apache ZooKeeper")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"distributed-storage-with-rook-io"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#distributed-storage-with-rook-io","aria-hidden":"true"}},[this._v("#")]),this._v(" Distributed Storage with Rook.io")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"service-discovery-with-hashicorp-consul"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#service-discovery-with-hashicorp-consul","aria-hidden":"true"}},[this._v("#")]),this._v(" Service Discovery with HashiCorp Consul")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"high-performance-data-processing-pipeline"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#high-performance-data-processing-pipeline","aria-hidden":"true"}},[this._v("#")]),this._v(" High Performance Data Processing Pipeline")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"fully-asynchronous-pipeline-processing"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fully-asynchronous-pipeline-processing","aria-hidden":"true"}},[this._v("#")]),this._v(" Fully Asynchronous Pipeline Processing")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"persistent-api-connectivity-between-microservices"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#persistent-api-connectivity-between-microservices","aria-hidden":"true"}},[this._v("#")]),this._v(" Persistent API Connectivity Between Microservices")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"using-grpc-for-a-performance-boost"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#using-grpc-for-a-performance-boost","aria-hidden":"true"}},[this._v("#")]),this._v(" Using gRPC for a Performance Boost")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"distributed-multitenancy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#distributed-multitenancy","aria-hidden":"true"}},[this._v("#")]),this._v(" Distributed Multitenancy")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"global-microservices"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#global-microservices","aria-hidden":"true"}},[this._v("#")]),this._v(" Global Microservices")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"multitenant-microservices"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#multitenant-microservices","aria-hidden":"true"}},[this._v("#")]),this._v(" Multitenant Microservices")])}],!1,null,null,null);a.options.__file="architecture.md";t.default=a.exports}}]);