(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{234:function(e,a,i){"use strict";i.r(a);var s=i(1),n=Object(s.a)({},function(){var e=this,a=e.$createElement,i=e._self._c||a;return i("div",{staticClass:"content"},[e._m(0),e._v(" "),i("Seo"),e._v(" "),i("p",[e._v("SiteWhere ha sido diseñado desde cero para aprovechar lo último\nTecnologías para escalar eficientemente a las cargas esperadas en grandes proyecto de IoT.\nEn lugar de utilizar una arquitectura monolítica, SiteWhere promueve una arquitectura completamente\ndistribuida utilizando "),i("a",{attrs:{href:"https://kubernetes.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Kubernetes"),i("OutboundLink")],1),e._v(" como infraestructura y una variedad de\nmicroservicios para construir el sistema. Este enfoque permite la personalización y escalar en un nivel más fino\npara que el sistema se pueda adaptar a muchos casos posibles de uso de IoT. SiteWhere está construido con un\nenfoque de framework utilizando API claramente definidas para que las nuevas tecnologías pueden integrarse\nfácilmente a medida que evoluciona el ecosistema de IoT.")]),e._v(" "),e._m(1),e._v(" "),i("p",[e._v("SiteWhere está compuesto de microservicios basados ​​en Java que se construyen como\nimágenes "),i("a",{attrs:{href:"https://www.docker.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker"),i("OutboundLink")],1),e._v(" y se desplieguan en Kubernetes para\norquestación. Para simplificar la implementación, se utiliza "),i("a",{attrs:{href:"https://helm.sh/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Helm"),i("OutboundLink")],1),e._v(" para\nproporcionar plantillas estándar para varios escenarios de implementación. Los Helm\n"),i("a",{attrs:{href:"https://github.com/sitewhere/sitewhere-recipes/tree/master/charts",target:"_blank",rel:"noopener noreferrer"}},[e._v("charts"),i("OutboundLink")],1),e._v("\nsuministran todas las dependencias necesarias para ejecutar una instancia de SiteWhere completa,\nincluyendo tanto los microservicios y los componentes de infraestructura como Apache Zookeeper,\nApache Kafka y Mosquitto MQTT broker.")]),e._v(" "),e._m(2),e._v(" "),e._m(3),e._v(" "),e._m(4),e._v(" "),i("p",[e._v("Cada microservicio es una entidad completamente autónoma que tiene su\nEsquema de configuración propio, componentes internos, persistencia de datos y\nInteracciones con el pipeline de procesamiento de eventos. SiteWhere microservicios\nse construyen sobre un marco de microservicio personalizado y se ejecutan por separado\nProcesos "),i("a",{attrs:{href:"https://projects.spring.io/spring-boot/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Spring Boot"),i("OutboundLink")],1),e._v(", cada uno\ncontenido en su propia imagen "),i("a",{attrs:{href:"https://www.docker.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker"),i("OutboundLink")],1),e._v(".")]),e._v(" "),i("p",[e._v("Separar la lógica del sistema en microservicios permite las interacciones\nEntre varias áreas del sistema para ser definido más claramente. Esta\nLa transición ha dado lugar a una forma más comprensible y mantenible\nsistema y debe seguir pagando dividendos a medida que se agregan más características.")]),e._v(" "),e._m(5),e._v(" "),i("p",[e._v("La arquitectura de microservicio permite escalar áreas funcionales individuales del sistema.\nIndependientemente o se deja completamente fuera. En casos de uso donde el procesamiento REST tiende a\nSi se trata de un cuello de botella, se pueden ejecutar múltiples microservicios REST al mismo tiempo para manejar la carga.\nPor el contrario, servicios como la gestión de presencia que pueden no ser necesarios pueden dejarse\npara que la potencia de procesamiento se pueda dedicar a otros aspectos del sistema.")]),e._v(" "),e._m(6),e._v(" "),i("p",[e._v("La arquitectura 2.0 introduce el concepto de una instancia de SiteWhere, que\nPermite que el sistema distribuido actúe como una unidad cohesiva con algunos aspectos.\nA nivel global. Todos los microservicios para un solo SiteWhere\nLa instancia debe ejecutarse en la misma infraestructura de Kubernetes, aunque el sistema\nPuede distribuirse entre decenas o cientos de máquinas para distribuir el procesamiento.\ncarga.")]),e._v(" "),e._m(7),e._v(" "),i("p",[e._v("SiteWhere 2.0 mueve la configuración del sistema a "),i("a",{attrs:{href:"https://zookeeper.apache.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Apache ZooKeeper"),i("OutboundLink")],1),e._v("\nlo que permite externalizar la gestión de la configuración.\nhecho altamente disponible. ZooKeeper contiene un jerárquico\nestructura que representa la configuración de una o más instancias de SiteWhere\ny todos los microservicios que se utilizan para realizarlos.")]),e._v(" "),i("p",[e._v("Cada microservicio tiene una conexión directa a ZooKeeper y utiliza el\nJerarquía para determinar su configuración en tiempo de ejecución. Los microservicios escuchan los cambios.\nA los datos de configuración y reaccionar dinámicamente a las actualizaciones. Sin configuracion\nse almacena localmente dentro del microservicio, lo que evita problemas con\nmanteniendo los servicios sincronizados a medida que se actualiza la configuración del sistema.")]),e._v(" "),e._m(8),e._v(" "),i("p",[e._v("Dado que muchos de los componentes del sistema, como Zookeeper, Kafka y varios\nlas bases de datos requieren acceso a almacenamiento persistente, utiliza SiteWhere 2.0\n"),i("a",{attrs:{href:"https://rook.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Rook.io"),i("OutboundLink")],1),e._v(" dentro de Kubernetes para suministrar distribuido,\nalmacenamiento de bloque replicado que es resistente a las fallas de hardware mientras\nTodavía ofreciendo buenas características de rendimiento. Como almacenamiento y rendimiento.\nlas necesidades aumentan con el tiempo, los nuevos dispositivos de almacenamiento pueden estar disponibles\ndinamicamente. La arquitectura subyacente "),i("a",{attrs:{href:"https://ceph.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Ceph"),i("OutboundLink")],1),e._v("\nutilizado por Rook.io puede manejar "),i("em",[e._v("exobytes")]),e._v(" de datos mientras permite datos\npara ser resistente a las fallas a nivel de nodo, rack o incluso centro de datos.")]),e._v(" "),e._m(9),e._v(" "),i("p",[e._v("El proceso de procesamiento de eventos en SiteWhere 2.0 ha sido completamente rediseñado y utiliza\n[Apache Kafka] (https://kafka.apache.org/) para proporcionar un rendimiento resistente y de alto rendimiento\nMecanismo para procesar progresivamente datos de eventos del dispositivo. Los microservicios pueden conectarse a\npuntos clave en el proceso de procesamiento de eventos, lectura de datos de temas de entrada conocidos,\nprocesamiento de datos, luego envío de datos a temas salientes conocidos. Entes externos que\nestán interesados ​​en los datos que en cualquier punto de la tubería pueden actuar como consumidores del sitio\nTemas para utilizar los datos a medida que se mueve a través del sistema.")]),e._v(" "),e._m(10),e._v(" "),i("p",[e._v("En SiteWhere 2.0, cada conector de salida es un verdadero consumidor de Kafka con su propia compensación\nmarcador en la secuencia de eventos. Este mecanismo permite a los procesadores de salida procesar datos.\na su propio ritmo sin ralentizar a otros procesadores. También permite servicios a\naprovechar los grupos de consumidores de Kafka para distribuir la carga entre múltiples consumidores y\nprocesamiento de la escala en consecuencia.")]),e._v(" "),i("p",[e._v("::: propina\nEn la arquitectura de SiteWhere 1.x, la canalización para el procesamiento de salida utilizó un bloqueo\nenfoque que significa que cualquier procesador de salida único podría bloquear la canalización de salida.\nEsto ya no es un problema con la arquitectura 2.0.\n:::")]),e._v(" "),i("p",[e._v('El uso de Kafka también tiene otras ventajas que son aprovechadas por SiteWhere. Dado que todos los datos para\nEl registro distribuido se almacena en el disco, es posible "reproducir" la secuencia de eventos basada\nen datos previamente recopilados. Esto es extremadamente valioso para aspectos como la depuración.\nProcesando lógica o carga probando el sistema.')]),e._v(" "),e._m(11),e._v(" "),i("p",[e._v("Mientras que los datos de eventos del dispositivo generalmente fluyen en una tubería desde microservicio a microservicio en\nTemas de Kafka, también hay operaciones de API que deben ocurrir en tiempo real entre los\nmicroservicios Por ejemplo, la gestión de dispositivos y las funciones de gestión de eventos están contenidas en\nmicroservicios separados, por lo que cuando entran nuevos eventos en el sistema, el microservicio de procesamiento de entrada\nnecesita interactuar con la administración de dispositivos para buscar dispositivos existentes en el sistema y en los eventos\nGestión para persistir los eventos a un almacén de datos como\n[Apache Cassandra] (http://cassandra.apache.org/).")]),e._v(" "),e._m(12),e._v(" "),i("p",[e._v("En lugar de utilizar únicamente los servicios REST basados ​​en HTTP 1.x, que tienden a tener una\nsobrecarga de conexión, SiteWhere 2.0 utiliza [gRPC] (https://grpc.io/) para establecer una\nConexión entre microservicios que necesitan comunicarse entre sí. Desde que usa gRPC\nconexiones HTTP2 persistentes, la sobrecarga de las interacciones se reduce considerablemente, lo que permite\npara desacoplar sin una penalización de rendimiento significativa.")]),e._v(" "),i("p",[e._v("Todo el SiteWhere [modelo de datos] (https://github.com/sitewhere/sitewhere-java-api) se ha capturado en\nFormato de [Google Protocol Buffers] (https://developers.google.com/protocol-buffers/) para que\nPuede ser utilizado dentro de los servicios de GRPC. Todas las API de SiteWhere ahora se exponen directamente como\nLos servicios gRPC también permiten un acceso de alto rendimiento y baja latencia a lo que anteriormente se\nSolo accesible vía REST. Las API de REST todavía están disponibles a través del microservicio Web / REST,\npero utilizan las [gRPC API] (https://github.com/sitewhere/sitewhere-grpc-api) debajo de\npara proporcionar un enfoque coherente para acceder a los datos.")]),e._v(" "),i("p",[e._v("Dado que la cantidad de instancias de un microservicio determinado puede cambiar con el tiempo a medida que el servicio es\nescalada hacia arriba o hacia abajo, SiteWhere maneja automáticamente el proceso de conexión / desconexión de la\nTubos gRPC entre microservicios. Cada cliente gRPC saliente se descompone en el conjunto\nde servicios que pueden satisfacer las solicitudes, permitiendo que las solicitudes se procesen en paralelo.")]),e._v(" "),e._m(13),e._v(" "),i("p",[e._v('El enfoque de SiteWhere 1.x para la multitenencia consistió en utilizar un "motor de inquilino" separado para cada inquilino.\nEl motor admitía todas las tareas específicas del arrendatario, como la persistencia de datos, el procesamiento de eventos, etc.\nDesde que SiteWhere 2.0 se ha movido a una arquitectura de microservicios, el modelo multitenant ha sido\ndistribuido también. SiteWhere admite dos tipos de microservicios: global y multitenant.')]),e._v(" "),e._m(14),e._v(" "),i("p",[e._v("Los microservicios globales no manejan tareas específicas del arrendatario. Estos servicios manejan aspectos tales\ncomo la gestión de usuarios en toda la instancia y la gestión de inquilinos que no son específicas para individuos\ninquilinos del sistema. El microservicio Web / REST que admite los servicios REST y el usuario Swagger\nLa interfaz también es un servicio global, ya que admite un contenedor web separado para cada inquilino\nsería engorroso y rompería las aplicaciones existentes de SiteWhere 1.x. También hay una\nmicroservicio de administración de instancias globales que controla varios aspectos de la instancia completa\ne informes de actualizaciones a los microservicios individuales a través de Kafka.")]),e._v(" "),e._m(15),e._v(" "),i("p",[e._v("La mayoría de los servicios de SiteWhere 2.0 son microservicios multitenant que delegan tráfico\na los motores de inquilinos que hacen el procesamiento real. Por ejemplo, el microservicio de procesamiento de entrada\nen realidad consta de muchos motores inquilinos de procesamiento de entrada, cada uno de los cuales se configura por separado\ny se puede iniciar / detener / reconfigurar sin afectar a los motores de otros inquilinos.")]),e._v(" "),i("p",[e._v("El nuevo enfoque de los motores de inquilinos cambia la dinámica del procesamiento de eventos de SiteWhere. Esto es ahora\nes posible detener un solo motor inquilino sin la necesidad de detener los motores inquilinos que se ejecutan en\nOtros microservicios. Por ejemplo, el procesamiento de entrada para un inquilino se puede detener\ny reconfigurado mientras el resto de la tubería del inquilino continúa procesando. Desde nuevo\nse puede permitir que los eventos se acumulen en Kafka, el motor del inquilino se puede detener, reconfigurar,\ny reinicie, luego reanude donde lo dejó sin pérdida de datos.")])],1)},[function(){var e=this.$createElement,a=this._self._c||e;return a("h1",{attrs:{id:"arquitectura-del-sistema"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#arquitectura-del-sistema","aria-hidden":"true"}},[this._v("#")]),this._v(" Arquitectura del sistema")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h2",{attrs:{id:"kubernetes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes","aria-hidden":"true"}},[this._v("#")]),this._v(" Kubernetes")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h2",{attrs:{id:"microservicios"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#microservicios","aria-hidden":"true"}},[this._v("#")]),this._v(" Microservicios")])},function(){var e=this.$createElement,a=this._self._c||e;return a("p",[this._v("Una "),a("em",[this._v("instancia")]),this._v(" de SiteWhere es un sistema distribuido compuesto de muchos microservicios,\ncada uno de los cuales cumple una función específica y está completamente desacoplado de\nLos otros servicios. Los microservicios utilizan un mecanismo de descubrimiento de servicios para\nauto-ensamblar en un sistema de trabajo.")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"separacion-de-intereses"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#separacion-de-intereses","aria-hidden":"true"}},[this._v("#")]),this._v(" Separación de intereses")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"escala-lo-que-necesitas-deja-fuera-lo-que-no"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#escala-lo-que-necesitas-deja-fuera-lo-que-no","aria-hidden":"true"}},[this._v("#")]),this._v(" Escala lo que necesitas. Deja fuera lo que no")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h2",{attrs:{id:"gestion-de-instancias"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gestion-de-instancias","aria-hidden":"true"}},[this._v("#")]),this._v(" Gestión de instancias")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"gestion-de-configuracion-centralizada-con-apache-zookeeper"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gestion-de-configuracion-centralizada-con-apache-zookeeper","aria-hidden":"true"}},[this._v("#")]),this._v(" Gestión de configuración centralizada con Apache ZooKeeper")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"almacenamiento-distribuido-con-rook-io"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#almacenamiento-distribuido-con-rook-io","aria-hidden":"true"}},[this._v("#")]),this._v(" Almacenamiento distribuido con Rook.io")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h2",{attrs:{id:"canalizacion-de-procesamiento-de-datos-de-alto-rendimiento"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#canalizacion-de-procesamiento-de-datos-de-alto-rendimiento","aria-hidden":"true"}},[this._v("#")]),this._v(" Canalización de procesamiento de datos de alto rendimiento")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"procesamiento-de-tuberia-completamente-asincrono"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#procesamiento-de-tuberia-completamente-asincrono","aria-hidden":"true"}},[this._v("#")]),this._v(" Procesamiento de tubería completamente asíncrono")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h2",{attrs:{id:"conectividad-de-api-persistente-entre-microservicios"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#conectividad-de-api-persistente-entre-microservicios","aria-hidden":"true"}},[this._v("#")]),this._v(" Conectividad de API persistente entre microservicios")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"usando-grpc-para-un-aumento-de-rendimiento"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usando-grpc-para-un-aumento-de-rendimiento","aria-hidden":"true"}},[this._v("#")]),this._v(" Usando gRPC para un aumento de rendimiento")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h2",{attrs:{id:"multipropiedad-distribuida"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#multipropiedad-distribuida","aria-hidden":"true"}},[this._v("#")]),this._v(" Multipropiedad Distribuida")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"microservicios-globales"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#microservicios-globales","aria-hidden":"true"}},[this._v("#")]),this._v(" Microservicios globales")])},function(){var e=this.$createElement,a=this._self._c||e;return a("h3",{attrs:{id:"microservicios-multitenant"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#microservicios-multitenant","aria-hidden":"true"}},[this._v("#")]),this._v(" Microservicios Multitenant")])}],!1,null,null,null);n.options.__file="architecture.md";a.default=n.exports}}]);